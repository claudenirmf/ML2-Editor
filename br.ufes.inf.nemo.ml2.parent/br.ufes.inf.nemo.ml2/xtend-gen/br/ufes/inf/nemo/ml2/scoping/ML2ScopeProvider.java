/**
 * generated by Xtext 2.10.0
 */
package br.ufes.inf.nemo.ml2.scoping;

import br.ufes.inf.nemo.ml2.meta.Attribute;
import br.ufes.inf.nemo.ml2.meta.AttributeAssignment;
import br.ufes.inf.nemo.ml2.meta.EntityDeclaration;
import br.ufes.inf.nemo.ml2.meta.FeatureAssignment;
import br.ufes.inf.nemo.ml2.meta.ML2Class;
import br.ufes.inf.nemo.ml2.meta.MetaPackage;
import br.ufes.inf.nemo.ml2.meta.Reference;
import br.ufes.inf.nemo.ml2.meta.ReferenceAssignment;
import br.ufes.inf.nemo.ml2.scoping.AbstractML2ScopeProvider;
import br.ufes.inf.nemo.ml2.util.ML2Util;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class ML2ScopeProvider extends AbstractML2ScopeProvider {
  @Inject
  @Extension
  private ML2Util _mL2Util;
  
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    if (((context instanceof AttributeAssignment) && Objects.equal(reference, MetaPackage.eINSTANCE.getAttributeAssignment_Attribute()))) {
      return this.getScopeForAttributeAssignmentOnAttributeAssignment_Attribute(context, reference);
    } else {
      if (((context instanceof ReferenceAssignment) && Objects.equal(reference, MetaPackage.eINSTANCE.getReferenceAssignment_Reference()))) {
        return this.getScopeForReferenceAssignmentOnReferenceAssignment_Reference(context, reference);
      } else {
        if (((context instanceof Attribute) && Objects.equal(reference, MetaPackage.eINSTANCE.getAttribute_SubsetOf()))) {
          return this.getScopeForAttributeOnAttribute_SubsetOf(context, reference);
        } else {
          if (((context instanceof Reference) && Objects.equal(reference, MetaPackage.eINSTANCE.getReference_SubsetOf()))) {
            return this.getScopeForReferenceOnReference_SubsetOf(context, reference);
          } else {
            if (((context instanceof Reference) && Objects.equal(reference, MetaPackage.eINSTANCE.getReference_OppositeTo()))) {
              return this.getScopeForReferenceOnReference_OppositeTo(context, reference);
            } else {
              if (((context instanceof Attribute) && Objects.equal(reference, MetaPackage.eINSTANCE.getFeature_RegulatedFeature()))) {
                return this.getScopeForAttributeOnProperty_ReguletedProperty(context, reference);
              } else {
                if (((context instanceof Reference) && Objects.equal(reference, MetaPackage.eINSTANCE.getFeature_RegulatedFeature()))) {
                  return this.getScopeForReferenceOnProperty_ReguletedProperty(context, reference);
                } else {
                  return super.getScope(context, reference);
                }
              }
            }
          }
        }
      }
    }
  }
  
  private IScope getScopeForAttributeAssignmentOnAttributeAssignment_Attribute(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final EntityDeclaration entity = ((EntityDeclaration) _eContainer);
    final Set<Attribute> attributes = this._mL2Util.getAllAttributes(entity);
    final Function<Attribute, QualifiedName> _function = (Attribute att) -> {
      final Function1<Attribute, Boolean> _function_1 = (Attribute it) -> {
        return Boolean.valueOf((it.getName().equals(att.getName()) && (!Objects.equal(it, att))));
      };
      boolean _exists = IterableExtensions.<Attribute>exists(attributes, _function_1);
      if (_exists) {
        EObject _eContainer_1 = att.eContainer();
        String _name = ((EntityDeclaration) _eContainer_1).getName();
        String _name_1 = att.getName();
        return QualifiedName.create(_name, _name_1);
      } else {
        String _name_2 = att.getName();
        return QualifiedName.create(_name_2);
      }
    };
    EList<FeatureAssignment> _assignments = entity.getAssignments();
    IScope _scopeFor = Scopes.scopeFor(_assignments);
    return Scopes.<Attribute>scopeFor(attributes, _function, _scopeFor);
  }
  
  private IScope getScopeForReferenceAssignmentOnReferenceAssignment_Reference(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final EntityDeclaration entity = ((EntityDeclaration) _eContainer);
    final Set<Reference> references = this._mL2Util.getAllReferences(entity);
    final Iterable<Reference> dup = Iterables.<Reference>concat(references, references);
    final Function<Reference, QualifiedName> _function = (Reference ref) -> {
      final Function1<Reference, Boolean> _function_1 = (Reference it) -> {
        return Boolean.valueOf((it.getName().equals(ref.getName()) && (!Objects.equal(it, ref))));
      };
      boolean _exists = IterableExtensions.<Reference>exists(references, _function_1);
      if (_exists) {
        EObject _eContainer_1 = ref.eContainer();
        String _name = ((EntityDeclaration) _eContainer_1).getName();
        String _name_1 = ref.getName();
        return QualifiedName.create(_name, _name_1);
      } else {
        String _name_2 = ref.getName();
        return QualifiedName.create(_name_2);
      }
    };
    EList<FeatureAssignment> _assignments = entity.getAssignments();
    IScope _scopeFor = Scopes.scopeFor(_assignments);
    return Scopes.<Reference>scopeFor(dup, _function, _scopeFor);
  }
  
  private IScope getScopeForAttributeOnAttribute_SubsetOf(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final Set<Attribute> inheritedAtts = this._mL2Util.getAllInheritedAttributes(c);
    final Function<Attribute, QualifiedName> _function = (Attribute att) -> {
      final Function1<Attribute, Boolean> _function_1 = (Attribute it) -> {
        return Boolean.valueOf((it.getName().equals(att.getName()) && (!Objects.equal(it, att))));
      };
      boolean _exists = IterableExtensions.<Attribute>exists(inheritedAtts, _function_1);
      if (_exists) {
        EObject _eContainer_1 = att.eContainer();
        String _name = ((EntityDeclaration) _eContainer_1).getName();
        String _name_1 = att.getName();
        return QualifiedName.create(_name, _name_1);
      } else {
        String _name_2 = att.getName();
        return QualifiedName.create(_name_2);
      }
    };
    EList<Attribute> _attributes = c.getAttributes();
    IScope _scopeFor = Scopes.scopeFor(_attributes);
    return Scopes.<Attribute>scopeFor(inheritedAtts, _function, _scopeFor);
  }
  
  private IScope getScopeForReferenceOnReference_SubsetOf(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final Set<Reference> inheritedRefs = this._mL2Util.getAllInheritedReferences(c);
    final Function<Reference, QualifiedName> _function = (Reference ref) -> {
      final Function1<Reference, Boolean> _function_1 = (Reference it) -> {
        return Boolean.valueOf((it.getName().equals(ref.getName()) && (!Objects.equal(it, ref))));
      };
      boolean _exists = IterableExtensions.<Reference>exists(inheritedRefs, _function_1);
      if (_exists) {
        EObject _eContainer_1 = ref.eContainer();
        String _name = ((EntityDeclaration) _eContainer_1).getName();
        String _name_1 = ref.getName();
        return QualifiedName.create(_name, _name_1);
      } else {
        String _name_2 = ref.getName();
        return QualifiedName.create(_name_2);
      }
    };
    EList<Reference> _references = c.getReferences();
    IScope _scopeFor = Scopes.scopeFor(_references);
    return Scopes.<Reference>scopeFor(inheritedRefs, _function, _scopeFor);
  }
  
  private IScope getScopeForReferenceOnReference_OppositeTo(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final Reference ref = ((Reference) context);
    ML2Class __type = ref.get_type();
    EList<Reference> _references = __type.getReferences();
    final Function1<Reference, Boolean> _function = (Reference it) -> {
      ML2Class __type_1 = it.get_type();
      return Boolean.valueOf(Objects.equal(__type_1, c));
    };
    Iterable<Reference> _filter = IterableExtensions.<Reference>filter(_references, _function);
    final Function<Reference, QualifiedName> _function_1 = (Reference it) -> {
      String _name = it.getName();
      return QualifiedName.create(_name);
    };
    EList<Reference> _references_1 = c.getReferences();
    IScope _scopeFor = Scopes.scopeFor(_references_1);
    return Scopes.<Reference>scopeFor(_filter, _function_1, _scopeFor);
  }
  
  private IScope getScopeForAttributeOnProperty_ReguletedProperty(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final BasicEList<Attribute> elements = new BasicEList<Attribute>();
    ML2Class _categorizedClass = c.getCategorizedClass();
    boolean _tripleNotEquals = (_categorizedClass != null);
    if (_tripleNotEquals) {
      ML2Class _categorizedClass_1 = c.getCategorizedClass();
      EList<Attribute> _attributes = _categorizedClass_1.getAttributes();
      elements.addAll(_attributes);
    }
    final Function<Attribute, QualifiedName> _function = (Attribute it) -> {
      String _name = it.getName();
      return QualifiedName.create(_name);
    };
    return Scopes.<Attribute>scopeFor(elements, _function, IScope.NULLSCOPE);
  }
  
  private IScope getScopeForReferenceOnProperty_ReguletedProperty(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final BasicEList<Reference> elements = new BasicEList<Reference>();
    ML2Class _categorizedClass = c.getCategorizedClass();
    boolean _tripleNotEquals = (_categorizedClass != null);
    if (_tripleNotEquals) {
      ML2Class _categorizedClass_1 = c.getCategorizedClass();
      EList<Reference> _references = _categorizedClass_1.getReferences();
      elements.addAll(_references);
    }
    final Function<Reference, QualifiedName> _function = (Reference it) -> {
      String _name = it.getName();
      return QualifiedName.create(_name);
    };
    return Scopes.<Reference>scopeFor(elements, _function, IScope.NULLSCOPE);
  }
}
