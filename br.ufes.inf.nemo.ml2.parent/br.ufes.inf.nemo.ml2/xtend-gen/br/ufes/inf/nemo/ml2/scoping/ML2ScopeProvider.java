/**
 * generated by Xtext 2.10.0
 */
package br.ufes.inf.nemo.ml2.scoping;

import br.ufes.inf.nemo.ml2.meta.Attribute;
import br.ufes.inf.nemo.ml2.meta.AttributeAssignment;
import br.ufes.inf.nemo.ml2.meta.EntityDeclaration;
import br.ufes.inf.nemo.ml2.meta.ML2Class;
import br.ufes.inf.nemo.ml2.meta.MetaPackage;
import br.ufes.inf.nemo.ml2.meta.Reference;
import br.ufes.inf.nemo.ml2.meta.ReferenceAssignment;
import br.ufes.inf.nemo.ml2.scoping.AbstractML2ScopeProvider;
import br.ufes.inf.nemo.ml2.util.ML2Util;
import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.common.util.BasicEList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class ML2ScopeProvider extends AbstractML2ScopeProvider {
  @Inject
  @Extension
  private ML2Util _mL2Util;
  
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    if (((context instanceof AttributeAssignment) && Objects.equal(reference, MetaPackage.eINSTANCE.getAttributeAssignment_Attribute()))) {
      return this.getScopeForAttributeAssignmentOnAttributeAssignment_Attribute(context, reference);
    } else {
      if (((context instanceof ReferenceAssignment) && Objects.equal(reference, MetaPackage.eINSTANCE.getReferenceAssignment_Reference()))) {
        return this.getScopeForReferenceAssignmentOnReferenceAssignment_Reference(context, reference);
      } else {
        if (((context instanceof Attribute) && Objects.equal(reference, MetaPackage.eINSTANCE.getAttribute_SubsetOf()))) {
          return this.getScopeForAttributeOnAttribute_SubsetOf(context, reference);
        } else {
          if (((context instanceof Reference) && Objects.equal(reference, MetaPackage.eINSTANCE.getReference_SubsetOf()))) {
            return this.getScopeForReferenceOnReference_SubsetOf(context, reference);
          } else {
            if (((context instanceof Reference) && Objects.equal(reference, MetaPackage.eINSTANCE.getReference_OppositeTo()))) {
              return this.getScopeForReferenceOnReference_OppositeTo(context, reference);
            } else {
              if (((context instanceof Attribute) && Objects.equal(reference, MetaPackage.eINSTANCE.getFeature_RegulatedFeature()))) {
                return this.getScopeForAttributeOnProperty_ReguletedProperty(context, reference);
              } else {
                if (((context instanceof Reference) && Objects.equal(reference, MetaPackage.eINSTANCE.getFeature_RegulatedFeature()))) {
                  return this.getScopeForReferenceOnProperty_ReguletedProperty(context, reference);
                } else {
                  return super.getScope(context, reference);
                }
              }
            }
          }
        }
      }
    }
  }
  
  private IScope getScopeForAttributeAssignmentOnAttributeAssignment_Attribute(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final EntityDeclaration entity = ((EntityDeclaration) _eContainer);
    final Set<Attribute> attributes = this._mL2Util.getAllAttributes(entity);
    final Function<Attribute, QualifiedName> _function = (Attribute att) -> {
      final Function1<Attribute, Boolean> _function_1 = (Attribute it) -> {
        return Boolean.valueOf((it.getName().equals(att.getName()) && (!Objects.equal(it, att))));
      };
      boolean _exists = IterableExtensions.<Attribute>exists(attributes, _function_1);
      if (_exists) {
        EObject _eContainer_1 = att.eContainer();
        return QualifiedName.create(((EntityDeclaration) _eContainer_1).getName(), att.getName());
      } else {
        return QualifiedName.create(att.getName());
      }
    };
    return Scopes.<Attribute>scopeFor(attributes, _function, Scopes.scopeFor(entity.getAssignments()));
  }
  
  private IScope getScopeForReferenceAssignmentOnReferenceAssignment_Reference(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final EntityDeclaration entity = ((EntityDeclaration) _eContainer);
    final Set<Reference> references = this._mL2Util.getAllReferences(entity);
    final Iterable<Reference> dup = Iterables.<Reference>concat(references, references);
    final Function<Reference, QualifiedName> _function = (Reference ref) -> {
      final Function1<Reference, Boolean> _function_1 = (Reference it) -> {
        return Boolean.valueOf((it.getName().equals(ref.getName()) && (!Objects.equal(it, ref))));
      };
      boolean _exists = IterableExtensions.<Reference>exists(references, _function_1);
      if (_exists) {
        EObject _eContainer_1 = ref.eContainer();
        return QualifiedName.create(((EntityDeclaration) _eContainer_1).getName(), ref.getName());
      } else {
        return QualifiedName.create(ref.getName());
      }
    };
    return Scopes.<Reference>scopeFor(dup, _function, Scopes.scopeFor(entity.getAssignments()));
  }
  
  private IScope getScopeForAttributeOnAttribute_SubsetOf(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final Set<Attribute> inheritedAtts = this._mL2Util.getAllInheritedAttributes(c);
    final Function<Attribute, QualifiedName> _function = (Attribute att) -> {
      final Function1<Attribute, Boolean> _function_1 = (Attribute it) -> {
        return Boolean.valueOf((it.getName().equals(att.getName()) && (!Objects.equal(it, att))));
      };
      boolean _exists = IterableExtensions.<Attribute>exists(inheritedAtts, _function_1);
      if (_exists) {
        EObject _eContainer_1 = att.eContainer();
        return QualifiedName.create(((EntityDeclaration) _eContainer_1).getName(), att.getName());
      } else {
        return QualifiedName.create(att.getName());
      }
    };
    return Scopes.<Attribute>scopeFor(inheritedAtts, _function, Scopes.scopeFor(c.getAttributes()));
  }
  
  private IScope getScopeForReferenceOnReference_SubsetOf(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final Set<Reference> inheritedRefs = this._mL2Util.getAllInheritedReferences(c);
    final Function<Reference, QualifiedName> _function = (Reference ref) -> {
      final Function1<Reference, Boolean> _function_1 = (Reference it) -> {
        return Boolean.valueOf((it.getName().equals(ref.getName()) && (!Objects.equal(it, ref))));
      };
      boolean _exists = IterableExtensions.<Reference>exists(inheritedRefs, _function_1);
      if (_exists) {
        EObject _eContainer_1 = ref.eContainer();
        return QualifiedName.create(((EntityDeclaration) _eContainer_1).getName(), ref.getName());
      } else {
        return QualifiedName.create(ref.getName());
      }
    };
    return Scopes.<Reference>scopeFor(inheritedRefs, _function, Scopes.scopeFor(c.getReferences()));
  }
  
  private IScope getScopeForReferenceOnReference_OppositeTo(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final Reference ref = ((Reference) context);
    final Function1<Reference, Boolean> _function = (Reference it) -> {
      ML2Class __type = it.get_type();
      return Boolean.valueOf(Objects.equal(__type, c));
    };
    final Function<Reference, QualifiedName> _function_1 = (Reference it) -> {
      return QualifiedName.create(it.getName());
    };
    return Scopes.<Reference>scopeFor(IterableExtensions.<Reference>filter(ref.get_type().getReferences(), _function), _function_1, Scopes.scopeFor(c.getReferences()));
  }
  
  private IScope getScopeForAttributeOnProperty_ReguletedProperty(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final BasicEList<Attribute> elements = new BasicEList<Attribute>();
    ML2Class _categorizedClass = c.getCategorizedClass();
    boolean _tripleNotEquals = (_categorizedClass != null);
    if (_tripleNotEquals) {
      elements.addAll(c.getCategorizedClass().getAttributes());
    }
    final Function<Attribute, QualifiedName> _function = (Attribute it) -> {
      return QualifiedName.create(it.getName());
    };
    return Scopes.<Attribute>scopeFor(elements, _function, IScope.NULLSCOPE);
  }
  
  private IScope getScopeForReferenceOnProperty_ReguletedProperty(final EObject context, final EReference reference) {
    EObject _eContainer = context.eContainer();
    final ML2Class c = ((ML2Class) _eContainer);
    final BasicEList<Reference> elements = new BasicEList<Reference>();
    ML2Class _categorizedClass = c.getCategorizedClass();
    boolean _tripleNotEquals = (_categorizedClass != null);
    if (_tripleNotEquals) {
      elements.addAll(c.getCategorizedClass().getReferences());
    }
    final Function<Reference, QualifiedName> _function = (Reference it) -> {
      return QualifiedName.create(it.getName());
    };
    return Scopes.<Reference>scopeFor(elements, _function, IScope.NULLSCOPE);
  }
}
