/*
 * generated by Xtext 2.10.0
 */
package br.ufes.inf.nemo.ml2.scoping

import br.ufes.inf.nemo.ml2.meta.Attribute
import br.ufes.inf.nemo.ml2.meta.AttributeAssignment
import br.ufes.inf.nemo.ml2.meta.EntityDeclaration
import br.ufes.inf.nemo.ml2.meta.ML2Class
import br.ufes.inf.nemo.ml2.meta.MetaPackage
import br.ufes.inf.nemo.ml2.meta.Reference
import br.ufes.inf.nemo.ml2.meta.ReferenceAssignment
import br.ufes.inf.nemo.ml2.util.ML2Util
import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class ML2ScopeProvider extends AbstractML2ScopeProvider {

	@Inject extension ML2Util
	
	override getScope(EObject context, EReference reference){
		if(context instanceof AttributeAssignment && reference == MetaPackage.eINSTANCE.attributeAssignment_Attribute){
			return getScopeForAttributeAssignmentOnAttributeAssignment_Attribute(context,reference)
		} 
		else if(context instanceof ReferenceAssignment && reference == MetaPackage.eINSTANCE.referenceAssignment_Reference){
			return getScopeForReferenceAssignmentOnReferenceAssignment_Reference(context,reference)
		} 
		else if(context instanceof Attribute && reference == MetaPackage.eINSTANCE.attribute_SubsetOf){
			return getScopeForAttributeOnAttribute_SubsetOf(context,reference)
		} 
		else if(context instanceof Reference && reference == MetaPackage.eINSTANCE.reference_SubsetOf){
			return getScopeForReferenceOnReference_SubsetOf(context,reference)
		}
		else if(context instanceof Reference && reference==MetaPackage.eINSTANCE.reference_OppositeTo){
			return getScopeForReferenceOnReference_OppositeTo(context,reference)
		}
		else if(context instanceof Attribute && reference==MetaPackage.eINSTANCE.feature_RegulatedFeature){
			return getScopeForAttributeOnProperty_ReguletedProperty(context,reference)
		}
		else if(context instanceof Reference && reference==MetaPackage.eINSTANCE.feature_RegulatedFeature){
			return getScopeForReferenceOnProperty_ReguletedProperty(context,reference)
		}
		else return super.getScope(context, reference)
	}
	
	def private IScope getScopeForAttributeAssignmentOnAttributeAssignment_Attribute(EObject context, EReference reference){
		// TODO Add options to scope
		val entity = context.eContainer as EntityDeclaration
		val attributes = entity.allAttributes
		return Scopes.scopeFor(attributes, [ att |
			if (attributes.exists[it.name.equals(att.name) && it != att])
				return QualifiedName.create((att.eContainer as EntityDeclaration).name, att.name)
			else
				return QualifiedName.create(att.name)
		], Scopes.scopeFor(entity.assignments))
	}
	
	def private IScope getScopeForReferenceAssignmentOnReferenceAssignment_Reference(EObject context, EReference reference){
		// TODO Add options to scope
		val entity = context.eContainer as EntityDeclaration
		val references = entity.allReferences
		return Scopes.scopeFor(references, [ ref |
			if (references.exists[it.name.equals(ref.name) && it != ref])
				return QualifiedName.create((ref.eContainer as EntityDeclaration).name, ref.name)
			else
				return QualifiedName.create(ref.name)
		], Scopes.scopeFor(entity.assignments))
	}
	
	def private IScope getScopeForAttributeOnAttribute_SubsetOf(EObject context, EReference reference){
		val c = context.eContainer as ML2Class
		val inheritedAtts = c.allInheritedAttributes
		return Scopes.scopeFor(inheritedAtts, [ att |
			if (inheritedAtts.exists[it.name.equals(att.name) && it != att])
				return QualifiedName.create((att.eContainer as EntityDeclaration).name, att.name)
			else
				return QualifiedName.create(att.name)
		], Scopes.scopeFor(c.attributes))
	}
	
	def private IScope getScopeForReferenceOnReference_SubsetOf(EObject context, EReference reference){
		val c = context.eContainer as ML2Class
		val inheritedRefs = c.allInheritedReferences
		return Scopes.scopeFor(inheritedRefs, [ ref |
			if (inheritedRefs.exists[it.name.equals(ref.name) && it != ref])
				return QualifiedName.create((ref.eContainer as EntityDeclaration).name, ref.name)
			else
				return QualifiedName.create(ref.name)
		], Scopes.scopeFor(c.references))
	}
	
	def private getScopeForReferenceOnReference_OppositeTo(EObject context, EReference reference) {
		val c = context.eContainer as ML2Class
		val ref = context as Reference
		return Scopes.scopeFor(ref._type.references.filter[it._type==c],
			[ QualifiedName.create(it.name) ], Scopes.scopeFor(c.references))
	}
	
	def private getScopeForAttributeOnProperty_ReguletedProperty(EObject context, EReference reference) {
		val c = context.eContainer as ML2Class
		val elements = c?.categorizedClass.attributes
		return Scopes.scopeFor(elements, [ QualifiedName.create(it.name) ], IScope.NULLSCOPE)
	}
	
	def private getScopeForReferenceOnProperty_ReguletedProperty(EObject context, EReference reference) {
		val c = context.eContainer as ML2Class
		val elements = c?.categorizedClass.references
		return Scopes.scopeFor(elements, [ QualifiedName.create(it.name) ], IScope.NULLSCOPE)
	}
}
