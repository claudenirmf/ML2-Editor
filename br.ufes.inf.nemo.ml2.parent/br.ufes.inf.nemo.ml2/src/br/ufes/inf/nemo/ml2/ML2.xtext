grammar br.ufes.inf.nemo.ml2.ML2 with org.eclipse.xtext.common.Terminals

import "http://www.ufes.br/inf/nemo/ml2" as ml2
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model returns ml2::Model:
	'module' name=QualifiedName '{'
	('include' includes+=[ml2::Model|QualifiedName] ';' | elements+=ModelElement)*
	'}';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

Import returns ml2::Import:
	'import' importedNamespace = QualifiedNameWithWildcard;
	
ModelElement returns ml2::ModelElement:
	( Import | EntityDeclaration | GeneralizationSet ) ';' ;

EntityDeclaration returns ml2::EntityDeclaration:
	Class | Individual ;

Individual returns ml2::Individual:
	'individual' name=ID
	':' instantiates+=[ml2::Class|QualifiedName] 
			(',' instantiates+=[ml2::Class|QualifiedName])*
	( '{' assignments+=FeatureAssignment* '}' )? ;

Class returns ml2::Class:
	( FOClassOrDataType | HigherOrderClass )
	('{' ( assignments+=FeatureAssignment | features+=Feature )* '}')? ;

FOClassOrDataType returns ml2::Class:
	( FOClass | DataType ) 
	(':' instantiates+=[ml2::Class|QualifiedName] 
		(',' instantiates+=[ml2::Class|QualifiedName])*) ?
	('specializes' superClasses+=[ml2::Class|QualifiedName] 
		(',' superClasses+=[ml2::Class|QualifiedName])*) ? ;

HigherOrderClass returns ml2::Class:
	( HOClass | OrderlessClass )
	(':' instantiates+=[ml2::Class|QualifiedName] 
		(',' instantiates+=[ml2::Class|QualifiedName])*) ?
	('specializes' superClasses+=[ml2::Class|QualifiedName] 
		(',' superClasses+=[ml2::Class|QualifiedName])*) ?
	('subordinatedTo' subordinators+=[ml2::Class|QualifiedName] 
		(',' subordinators+=[ml2::Class|QualifiedName])*) ?
	( categorizationType=CategorizationType categorizedClass=[ml2::Class|QualifiedName]
		| 'isPowertypeOf' powertypeOf=[ml2::Class|QualifiedName] ) ? ;

enum CategorizationType returns ml2::CategorizationType:
	CATEGORIZER | COMPLETE_CATEGORIZER | DISJOINT_CATEGORIZER | PARTITIONER ;

FOClass returns ml2::FOClass:
	'class' name=ID ;

DataType returns ml2::DataType:
	'datatype' name=ID ;

HOClass returns ml2::HOClass:
	'order' order=INT 'class' name=ID ; 

OrderlessClass returns ml2::OrderlessClass:
	'orderless' 'class' name=ID ;

GeneralizationSet returns ml2::GeneralizationSet:
	(isDisjoint?='disjoint'? & isComplete?='complete'?) 'genset' (name=ID)? 
	'general' general=[ml2::Class|QualifiedName]
	('categorizer' categorizer=[ml2::Class|QualifiedName])? 
	'specifics' specifics+=[ml2::Class|QualifiedName] (',' specifics+=[ml2::Class|QualifiedName])+ ;

Feature returns ml2::Feature:
	CommonFeature | RegularityFeature ;

CommonFeature returns ml2::Feature:
	Attribute | Reference ;

RegularityFeature returns ml2::Feature:
	RegularityAttribute | RegularityReference ;

Attribute returns ml2::Attribute:
	'att'? name=ID ':' 
//	('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']') ? 
	(primitiveType=PrimitiveType | _type=[ml2::DataType|QualifiedName])
	('subsets' subsetOf+=[ml2::Attribute|QualifiedName] 
		(',' subsetOf+=[ml2::Attribute|QualifiedName])* ) ? ;

Reference returns ml2::Reference:
	'ref' name=ID ':' 
//	('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')? _type=[ml2::Class|QualifiedName]
	('subsets' subsetOf+=[ml2::Reference|QualifiedName] 
		(',' subsetOf+=[ml2::Reference|QualifiedName])*) ?
	('isOppositeTo' oppositeTo=[ml2::Reference|QualifiedName])? ;

RegularityAttribute returns ml2::Attribute:
	'regularity' 'att'? name=ID ':' 
//	('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']') ? 
	(primitiveType=PrimitiveType | _type=[ml2::DataType|QualifiedName])
	('subsets' subsetOf+=[ml2::Attribute|QualifiedName] 
		(',' subsetOf+=[ml2::Attribute|QualifiedName])* ) ?
	regularityType=RegularityFeatureType regulatedFeature=[ml2::Feature|QualifiedName] ;

RegularityReference returns ml2::Reference:
	'regularity' 'ref' name=ID ':' 
//	('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')? _type=[ml2::Class|QualifiedName]
	('subsets' subsetOf+=[ml2::Reference|QualifiedName] 
		(',' subsetOf+=[ml2::Reference|QualifiedName])*) ?
	('isOppositeTo' oppositeTo=[ml2::Reference|QualifiedName])?
	regularityType=RegularityFeatureType regulatedFeature=[ml2::Feature|QualifiedName] ;

//ELEMENTBOUND returns ecore::EInt:
//	'*' | INT ;
	
enum PrimitiveType returns ml2::PrimitiveType:
	STRING | NUMBER | BOOLEAN ;


enum RegularityFeatureType returns ml2::RegularityFeatureType:
	DETERMINES_VALUE | DETERMINES_TYPE | DETERMINES_MIN_VALUE
	| DETERMINES_ALLOWED_VALUES | DETERMINES_ALLOWED_TYPES | DETERMINES_MAX_VALUE ;

FeatureAssignment returns ml2::FeatureAssignment:
	ReferenceAssignment | SingleAttributeAssignment ; // | MultipleAttributeAssignment ;

SingleAttributeAssignment returns ml2::AttributeAssignment: 
	'att'? attribute=[ml2::Attribute|QualifiedName] '='
	( individualAssignments+=[ml2::Individual|QualifiedName] );
//		| unnamedIndividualAssignments+=UnnamedIndividual );
//		| literalAssignments+=Literal ) ;

//MultipleAttributeAssignment returns ml2::AttributeAssignment: 
//	'att'? attribute=[ml2::Attribute|QualifiedName] '=' '{'
////	((literalAssignments+=Literal (',' literalAssignments+=Literal)*)
//	(((individualAssignments+=[ml2::Individual|QualifiedName] | unnamedIndividualAssignments+=UnnamedIndividual)
//	(',' (individualAssignments+=[ml2::Individual|QualifiedName] | unnamedIndividualAssignments+=UnnamedIndividual))*
//	) 
//	)?  '}';

ReferenceAssignment returns ml2::ReferenceAssignment: 
	'ref' reference=[ml2::Reference|QualifiedName] '='
	( assignments+=[ml2::EntityDeclaration|QualifiedName]
		| '{' assignments+=[ml2::EntityDeclaration|QualifiedName] 
			(',' assignments+=[ml2::EntityDeclaration|QualifiedName])* '}' ) ;

//Literal returns ml2::Literal:
//	ML2String | ML2Number | ML2Boolean ;
//
//ML2String returns ml2::String:
//	value=STRING;
//
//ML2Number returns ml2::Number:
//	value=NUMBER;
//
//ML2Boolean returns ml2::Boolean:
//	value=BOOLEAN;
//
//BOOLEAN returns ecore::EBoolean:
//	'true' | 'false';
//
//NUMBER returns ecore::EDouble:
//	'-'? INT ( '.' INT )? ;

//UnnamedIndividual returns ml2::Individual:
//	{ml2::Individual} '[' assignments+=SimpleAttributeAssignment* ']' ;

//SimpleAttributeAssignment returns ml2::AttributeAssignment:
//	attribute=[ml2::Attribute|QualifiedName] '='
//	( individualAssignments+=[ml2::Individual|QualifiedName]
//		| unnamedIndividualAssignments+=UnnamedIndividual
//		| literalAssignments+=Literal
//		| '{'
//			((literalAssignments+=Literal (',' literalAssignments+=Literal)*)
//			| ((individualAssignments+=[ml2::Individual|QualifiedName] | unnamedIndividualAssignments+=UnnamedIndividual) 
//				(',' (individualAssignments+=[ml2::Individual|QualifiedName] | unnamedIndividualAssignments+=UnnamedIndividual))*)
//		)? '}' ) ;


