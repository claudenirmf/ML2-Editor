// automatically generated by Xtext
grammar br.ufes.inf.nemo.ml2.ML2 with org.eclipse.xtext.common.Terminals

import "http://www.nemo.inf.ufes.br/ml2/ML2" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

ML2Model:
	'module' name=QualifiedName '{'
	('include' includes+=[ML2Model|QualifiedName] ';' | elements+=ModelElement)*
	'}';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

Import:
	'import' importedNamespace = QualifiedNameWithWildcard;
	
ModelElement:
	( Import | EntityDeclaration | GeneralizationSet ) ';' ;

EntityDeclaration:
	ML2Class | Individual ;

Individual:
	'individual' name=ID
	':' instantiatedClasses+=[ML2Class|QualifiedName] 
			(',' instantiatedClasses+=[ML2Class|QualifiedName])*
	( '{' assignments+=FeatureAssignment* '}' )? ;

ML2Class:
	( SomeFOClass | NonFOClass )
	('{' ( assignments+=FeatureAssignment | features+=Feature )* '}')? ;

SomeFOClass returns ML2Class:
	( FOClass | DataType ) 
	(':' instantiatedClasses+=[ML2Class|QualifiedName] 
		(',' instantiatedClasses+=[ML2Class|QualifiedName])*) ?
	('specializes' superClasses+=[ML2Class|QualifiedName] 
		(',' superClasses+=[ML2Class|QualifiedName])*) ? ;

NonFOClass returns ML2Class:
	( HOClass | OrderlessClass )
	(':' instantiatedClasses+=[ML2Class|QualifiedName] 
		(',' instantiatedClasses+=[ML2Class|QualifiedName])*) ?
	('specializes' superClasses+=[ML2Class|QualifiedName] 
		(',' superClasses+=[ML2Class|QualifiedName])*) ?
	('subordinatedTo' subordinators+=[ML2Class|QualifiedName] 
		(',' subordinators+=[ML2Class|QualifiedName])*) ?
	( categorizationType=CategorizationType categorizedClass=[ML2Class|QualifiedName]
		| 'isPowertypeOf' powertypeOf=[ML2Class|QualifiedName] ) ? ;

enum CategorizationType:
	CATEGORIZER | COMPLETE_CATEGORIZER | DISJOINT_CATEGORIZER | PARTITIONER ;

FOClass:
	'class' name=ID ;

DataType:
	'datatype' name=ID ;

HOClass:
	'order' order=INT 'class' name=ID ; 

OrderlessClass:
	'orderless' 'class' name=ID ;

GeneralizationSet:
	(isDisjoint?='disjoint'? & isComplete?='complete'?) 'genset' (name=ID)? 
	'general' general=[ML2Class|QualifiedName]
	('categorizer' categorizer=[ML2Class|QualifiedName])? 
	'specifics' specifics+=[ML2Class|QualifiedName] (',' specifics+=[ML2Class|QualifiedName])+ ;

Feature:
	CommonFeature | RegularityFeature ;

CommonFeature returns Feature:
	Attribute | Reference ;

RegularityFeature returns Feature:
	RegularityAttribute | RegularityReference ;

Attribute:
	'att'? name=ID ':' 
	('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']') ? _type=[DataType|QualifiedName]
	('subsets' subsetOf+=[Attribute|QualifiedName] 
		(',' subsetOf+=[Attribute|QualifiedName])* ) ? ;

Reference:
	'ref' name=ID ':' 
	('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')? _type=[ML2Class|QualifiedName]
	('subsets' subsetOf+=[Reference|QualifiedName] 
		(',' subsetOf+=[Reference|QualifiedName])*) ?
	('isOppositeTo' oppositeTo=[Reference|QualifiedName])? ;

RegularityAttribute returns Attribute:
	'regularity' 'att'? name=ID ':' 
	('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']') ? _type=[DataType|QualifiedName]
	('subsets' subsetOf+=[Attribute|QualifiedName] 
		(',' subsetOf+=[Attribute|QualifiedName])* ) ?
	regularityType=RegularityFeatureType regulatedFeature=[Feature|QualifiedName] ;

RegularityReference returns Reference:
	'regularity' 'ref' name=ID ':' 
	('[' lowerBound=ELEMENTBOUND '..' upperBound=ELEMENTBOUND ']')? _type=[ML2Class|QualifiedName]
	('subsets' subsetOf+=[Reference|QualifiedName] 
		(',' subsetOf+=[Reference|QualifiedName])*) ?
	('isOppositeTo' oppositeTo=[Reference|QualifiedName])?
	regularityType=RegularityFeatureType regulatedFeature=[Feature|QualifiedName] ;

ELEMENTBOUND returns ecore::EInt:
	'*' | INT ;

enum RegularityFeatureType:
	DETERMINES_VALUE | DETERMINES_TYPE |DETERMINES_MIN_VALUE
	| DETERMINES_ALLOWED_VALUES | DETERMINES_ALLOWED_TYPES | DETERMINES_MAX_VALUE ;

FeatureAssignment:
	SingleAttributeAssignment | MultipleAttributeAssignment | ReferenceAssignment ;

SingleAttributeAssignment returns AttributeAssignment: 
	'att'? attribute=[Attribute|QualifiedName] '='
	( entityAssignments+=[Individual|QualifiedName]
		| unnamedIndividualAssignments+=UnnamedIndividual
		| literalAssignments+=Literal ) ;

MultipleAttributeAssignment returns AttributeAssignment: 
	'att'? attribute=[Attribute|QualifiedName] '=' '{'
	((literalAssignments+=Literal (',' literalAssignments+=Literal)*)
		| ((entityAssignments+=[Individual|QualifiedName] | unnamedIndividualAssignments+=UnnamedIndividual)
			(',' (entityAssignments+=[Individual|QualifiedName] | unnamedIndividualAssignments+=UnnamedIndividual))*
		) 
	)?  '}';

ReferenceAssignment: 
	'ref' reference=[Reference|QualifiedName] '='
	( assignments+=[EntityDeclaration|QualifiedName]
		| '{' assignments+=[EntityDeclaration|QualifiedName] 
			(',' assignments+=[EntityDeclaration|QualifiedName])* '}' ) ;

Literal:
	ML2String | ML2Number | ML2Boolean ;

ML2String:
	value=STRING;

ML2Number:
	value=NUMBER;

ML2Boolean:
	value=BOOLEAN;

BOOLEAN returns ecore::EBoolean:
	'true' | 'false';

NUMBER returns ecore::EDouble:
	'-'? INT ( '.' INT (('E'|'e') '-'? INT)? )? ;

UnnamedIndividual returns Individual:
	{Individual} '[' assignments+=SimpleAttributeAssignment* ']' ;

SimpleAttributeAssignment returns AttributeAssignment:
	attribute=[Attribute|QualifiedName] '='
	( entityAssignments+=[Individual|QualifiedName]
		| unnamedIndividualAssignments+=UnnamedIndividual
		| literalAssignments+=Literal
		| '{'
			((literalAssignments+=Literal (',' literalAssignments+=Literal)*)
			| ((entityAssignments+=[Individual|QualifiedName] | unnamedIndividualAssignments+=UnnamedIndividual) 
				(',' (entityAssignments+=[Individual|QualifiedName] | unnamedIndividualAssignments+=UnnamedIndividual))*)
		)? '}' ) ;


