/*
 * generated by Xtext 2.21.0
 */
package br.ufes.inf.nemo.ml2.serializer;

import br.ufes.inf.nemo.ml2.model.AdditionExpression;
import br.ufes.inf.nemo.ml2.model.AdditionOperation;
import br.ufes.inf.nemo.ml2.model.AndExpression;
import br.ufes.inf.nemo.ml2.model.ArrowOperation;
import br.ufes.inf.nemo.ml2.model.Attribute;
import br.ufes.inf.nemo.ml2.model.AttributeAssignment;
import br.ufes.inf.nemo.ml2.model.BinaryIteration;
import br.ufes.inf.nemo.ml2.model.BinarySetOperation;
import br.ufes.inf.nemo.ml2.model.BooleanLiteralExpression;
import br.ufes.inf.nemo.ml2.model.CallExpression;
import br.ufes.inf.nemo.ml2.model.CollectionLiteralExpression;
import br.ufes.inf.nemo.ml2.model.CollectionTypeName;
import br.ufes.inf.nemo.ml2.model.ComparisonExpression;
import br.ufes.inf.nemo.ml2.model.ComparisonOperation;
import br.ufes.inf.nemo.ml2.model.DataType;
import br.ufes.inf.nemo.ml2.model.DataTypeName;
import br.ufes.inf.nemo.ml2.model.DerivationConstraint;
import br.ufes.inf.nemo.ml2.model.DotOperation;
import br.ufes.inf.nemo.ml2.model.FirstOrderClass;
import br.ufes.inf.nemo.ml2.model.GeneralizationSet;
import br.ufes.inf.nemo.ml2.model.HighOrderClass;
import br.ufes.inf.nemo.ml2.model.IfExpression;
import br.ufes.inf.nemo.ml2.model.ImpliesExpression;
import br.ufes.inf.nemo.ml2.model.Import;
import br.ufes.inf.nemo.ml2.model.Individual;
import br.ufes.inf.nemo.ml2.model.InvariantConstraint;
import br.ufes.inf.nemo.ml2.model.LetExpression;
import br.ufes.inf.nemo.ml2.model.Model;
import br.ufes.inf.nemo.ml2.model.ModelPackage;
import br.ufes.inf.nemo.ml2.model.MultiplicationExpression;
import br.ufes.inf.nemo.ml2.model.NullLiteralExpression;
import br.ufes.inf.nemo.ml2.model.NumberLiteralExpression;
import br.ufes.inf.nemo.ml2.model.OclTypeName;
import br.ufes.inf.nemo.ml2.model.OrExpression;
import br.ufes.inf.nemo.ml2.model.OrderlessClass;
import br.ufes.inf.nemo.ml2.model.PrimitiveTypeName;
import br.ufes.inf.nemo.ml2.model.Reference;
import br.ufes.inf.nemo.ml2.model.ReferenceAssignment;
import br.ufes.inf.nemo.ml2.model.RegularityAttribute;
import br.ufes.inf.nemo.ml2.model.RegularityReference;
import br.ufes.inf.nemo.ml2.model.RelationalExpression;
import br.ufes.inf.nemo.ml2.model.RelationalOperation;
import br.ufes.inf.nemo.ml2.model.StringLiteralExpression;
import br.ufes.inf.nemo.ml2.model.TupleLiteralExpression;
import br.ufes.inf.nemo.ml2.model.TupleTypeName;
import br.ufes.inf.nemo.ml2.model.UnaryExpression;
import br.ufes.inf.nemo.ml2.model.UnaryIteration;
import br.ufes.inf.nemo.ml2.model.UnarySetOperation;
import br.ufes.inf.nemo.ml2.model.VariableDeclaration;
import br.ufes.inf.nemo.ml2.model.VariableExpression;
import br.ufes.inf.nemo.ml2.model.XorExpression;
import br.ufes.inf.nemo.ml2.services.ML2GrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractML2SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ML2GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelPackage.ADDITION_EXPRESSION:
				sequence_AdditionExpression(context, (AdditionExpression) semanticObject); 
				return; 
			case ModelPackage.ADDITION_OPERATION:
				sequence_AdditionOperation(context, (AdditionOperation) semanticObject); 
				return; 
			case ModelPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case ModelPackage.ARROW_OPERATION:
				sequence_ArrowOperation(context, (ArrowOperation) semanticObject); 
				return; 
			case ModelPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ModelPackage.ATTRIBUTE_ASSIGNMENT:
				if (rule == grammarAccess.getMultipleAttributeAssignmentRule()) {
					sequence_MultipleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getModelElementRule()
						|| rule == grammarAccess.getFeatureAssignmentRule()) {
					sequence_MultipleAttributeAssignment_SingleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultipleSimpleAttributeAssignmentRule()) {
					sequence_MultipleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleAttributeAssignmentRule()) {
					sequence_MultipleSimpleAttributeAssignment_SingleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleAttributeAssignmentRule()) {
					sequence_SingleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleSimpleAttributeAssignmentRule()) {
					sequence_SingleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.BINARY_ITERATION:
				sequence_BinaryIteration(context, (BinaryIteration) semanticObject); 
				return; 
			case ModelPackage.BINARY_SET_OPERATION:
				sequence_BinarySetOperation(context, (BinarySetOperation) semanticObject); 
				return; 
			case ModelPackage.BOOLEAN_LITERAL_EXPRESSION:
				sequence_BooleanLiteralExpression(context, (BooleanLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.CALL_EXPRESSION:
				sequence_CallExpression(context, (CallExpression) semanticObject); 
				return; 
			case ModelPackage.COLLECTION_LITERAL_EXPRESSION:
				sequence_CollectionLiteralExpression(context, (CollectionLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.COLLECTION_TYPE_NAME:
				sequence_CollectionTypeName(context, (CollectionTypeName) semanticObject); 
				return; 
			case ModelPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case ModelPackage.COMPARISON_OPERATION:
				sequence_ComparisonOperation(context, (ComparisonOperation) semanticObject); 
				return; 
			case ModelPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case ModelPackage.DATA_TYPE_NAME:
				sequence_DataTypeName(context, (DataTypeName) semanticObject); 
				return; 
			case ModelPackage.DERIVATION_CONSTRAINT:
				sequence_DerivationConstraint(context, (DerivationConstraint) semanticObject); 
				return; 
			case ModelPackage.DOT_OPERATION:
				sequence_DotOperation(context, (DotOperation) semanticObject); 
				return; 
			case ModelPackage.FIRST_ORDER_CLASS:
				sequence_FirstOrderClass(context, (FirstOrderClass) semanticObject); 
				return; 
			case ModelPackage.GENERALIZATION_SET:
				sequence_GeneralizationSet(context, (GeneralizationSet) semanticObject); 
				return; 
			case ModelPackage.HIGH_ORDER_CLASS:
				sequence_HighOrderClass(context, (HighOrderClass) semanticObject); 
				return; 
			case ModelPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case ModelPackage.IMPLIES_EXPRESSION:
				sequence_ImpliesExpression(context, (ImpliesExpression) semanticObject); 
				return; 
			case ModelPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ModelPackage.INDIVIDUAL:
				if (rule == grammarAccess.getModelElementRule()
						|| rule == grammarAccess.getEntityDeclarationRule()
						|| rule == grammarAccess.getIndividualRule()) {
					sequence_Individual(context, (Individual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnnamedIndividualRule()) {
					sequence_UnnamedIndividual(context, (Individual) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.INVARIANT_CONSTRAINT:
				sequence_InvariantConstraint(context, (InvariantConstraint) semanticObject); 
				return; 
			case ModelPackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case ModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ModelPackage.MULTIPLICATION_EXPRESSION:
				sequence_MultiplicationExpression(context, (MultiplicationExpression) semanticObject); 
				return; 
			case ModelPackage.NULL_LITERAL_EXPRESSION:
				sequence_NullLiteralExpression(context, (NullLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.NUMBER_LITERAL_EXPRESSION:
				sequence_NumberLiteralExpression(context, (NumberLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.OCL_TYPE_NAME:
				sequence_OclTypeName(context, (OclTypeName) semanticObject); 
				return; 
			case ModelPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case ModelPackage.ORDERLESS_CLASS:
				sequence_OrderlessClass(context, (OrderlessClass) semanticObject); 
				return; 
			case ModelPackage.PRIMITIVE_TYPE_NAME:
				sequence_PrimitiveTypeName(context, (PrimitiveTypeName) semanticObject); 
				return; 
			case ModelPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case ModelPackage.REFERENCE_ASSIGNMENT:
				if (rule == grammarAccess.getMultipleReferenceAssignmentRule()) {
					sequence_MultipleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getModelElementRule()
						|| rule == grammarAccess.getFeatureAssignmentRule()) {
					sequence_MultipleReferenceAssignment_SingleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleReferenceAssignmentRule()) {
					sequence_SingleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.REGULARITY_ATTRIBUTE:
				sequence_RegularityAttribute(context, (RegularityAttribute) semanticObject); 
				return; 
			case ModelPackage.REGULARITY_REFERENCE:
				sequence_RegularityReference(context, (RegularityReference) semanticObject); 
				return; 
			case ModelPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case ModelPackage.RELATIONAL_OPERATION:
				sequence_RelationalOperation(context, (RelationalOperation) semanticObject); 
				return; 
			case ModelPackage.STRING_LITERAL_EXPRESSION:
				sequence_StringLiteralExpression(context, (StringLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.TUPLE_LITERAL_EXPRESSION:
				sequence_TupleLiteralExpression(context, (TupleLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.TUPLE_TYPE_NAME:
				sequence_TupleTypeName(context, (TupleTypeName) semanticObject); 
				return; 
			case ModelPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case ModelPackage.UNARY_ITERATION:
				sequence_UnaryIteration(context, (UnaryIteration) semanticObject); 
				return; 
			case ModelPackage.UNARY_SET_OPERATION:
				sequence_UnarySetOperation(context, (UnarySetOperation) semanticObject); 
				return; 
			case ModelPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case ModelPackage.VARIABLE_EXPRESSION:
				sequence_VariableExpression(context, (VariableExpression) semanticObject); 
				return; 
			case ModelPackage.XOR_EXPRESSION:
				sequence_XorExpression(context, (XorExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdditionExpression returns AdditionExpression
	 *
	 * Constraint:
	 *     (left=MultiplicationExpression right+=AdditionOperation*)
	 */
	protected void sequence_AdditionExpression(ISerializationContext context, AdditionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditionOperation returns AdditionOperation
	 *
	 * Constraint:
	 *     (operator=AdditionOperator right=MultiplicationExpression)
	 */
	protected void sequence_AdditionOperation(ISerializationContext context, AdditionOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ADDITION_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ADDITION_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ADDITION_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ADDITION_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionOperationAccess().getOperatorAdditionOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAdditionOperationAccess().getRightMultiplicationExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns AndExpression
	 *
	 * Constraint:
	 *     (left=ComparisonExpression right+=ComparisonExpression*)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns ArrowOperation
	 *     ArrowOperation returns ArrowOperation
	 *
	 * Constraint:
	 *     right=BuiltInOperation
	 */
	protected void sequence_ArrowOperation(ISerializationContext context, ArrowOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ARROW_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ARROW_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrowOperationAccess().getRightBuiltInOperationParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns Attribute
	 *     Feature returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         (primitiveType=PrimitiveType | _type=[DataType|QualifiedName]) 
	 *         (subsetOf+=[Attribute|QualifiedName] subsetOf+=[Attribute|QualifiedName]*)?
	 *     )
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BuiltInOperation returns BinaryIteration
	 *     BinaryIteration returns BinaryIteration
	 *
	 * Constraint:
	 *     ((variables+=ID variables+=ID)? body=OclExpression)
	 */
	protected void sequence_BinaryIteration(ISerializationContext context, BinaryIteration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BuiltInOperation returns BinarySetOperation
	 *     BinarySetOperation returns BinarySetOperation
	 *
	 * Constraint:
	 *     (operator=BinarySetOperator argument=OclExpression)
	 */
	protected void sequence_BinarySetOperation(ISerializationContext context, BinarySetOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_SET_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_SET_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_SET_OPERATION__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_SET_OPERATION__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinarySetOperationAccess().getOperatorBinarySetOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBinarySetOperationAccess().getArgumentOclExpressionParserRuleCall_2_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns BooleanLiteralExpression
	 *     LiteralExpression returns BooleanLiteralExpression
	 *     PrimitiveLiteralExpression returns BooleanLiteralExpression
	 *     BooleanLiteralExpression returns BooleanLiteralExpression
	 *
	 * Constraint:
	 *     booleanSymbol=BOOLEAN_LITERAL
	 */
	protected void sequence_BooleanLiteralExpression(ISerializationContext context, BooleanLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__BOOLEAN_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__BOOLEAN_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralExpressionAccess().getBooleanSymbolBOOLEAN_LITERALParserRuleCall_0(), semanticObject.isBooleanSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns CallExpression
	 *     CallExpression returns CallExpression
	 *
	 * Constraint:
	 *     (left=VariableExpression right+=CallOperation*)
	 */
	protected void sequence_CallExpression(ISerializationContext context, CallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns CollectionLiteralExpression
	 *     LiteralExpression returns CollectionLiteralExpression
	 *     CollectionLiteralExpression returns CollectionLiteralExpression
	 *
	 * Constraint:
	 *     (parts+=LiteralExpression parts+=LiteralExpression*)
	 */
	protected void sequence_CollectionLiteralExpression(ISerializationContext context, CollectionLiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns CollectionTypeName
	 *     LiteralExpression returns CollectionTypeName
	 *     TypeLiteralExpression returns CollectionTypeName
	 *     CollectionTypeName returns CollectionTypeName
	 *
	 * Constraint:
	 *     (typename='Set' elementType=TypeLiteralExpression)
	 */
	protected void sequence_CollectionTypeName(ISerializationContext context, CollectionTypeName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COLLECTION_TYPE_NAME__TYPENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COLLECTION_TYPE_NAME__TYPENAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COLLECTION_TYPE_NAME__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COLLECTION_TYPE_NAME__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionTypeNameAccess().getTypenameSetKeyword_0_0(), semanticObject.getTypename());
		feeder.accept(grammarAccess.getCollectionTypeNameAccess().getElementTypeTypeLiteralExpressionParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComparisonExpression returns ComparisonExpression
	 *
	 * Constraint:
	 *     (left=RelationalExpression right+=ComparisonOperation*)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComparisonOperation returns ComparisonOperation
	 *
	 * Constraint:
	 *     (operator=ComparisonOperator right=RelationalExpression)
	 */
	protected void sequence_ComparisonOperation(ISerializationContext context, ComparisonOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COMPARISON_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COMPARISON_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COMPARISON_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COMPARISON_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperationAccess().getOperatorComparisonOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getComparisonOperationAccess().getRightRelationalExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns DataTypeName
	 *     LiteralExpression returns DataTypeName
	 *     TypeLiteralExpression returns DataTypeName
	 *     DataTypeName returns DataTypeName
	 *
	 * Constraint:
	 *     typename=[DataType|ID]
	 */
	protected void sequence_DataTypeName(ISerializationContext context, DataTypeName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.DATA_TYPE_NAME__TYPENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.DATA_TYPE_NAME__TYPENAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeNameAccess().getTypenameDataTypeIDTerminalRuleCall_0_1(), semanticObject.eGet(ModelPackage.Literals.DATA_TYPE_NAME__TYPENAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns DataType
	 *     EntityDeclaration returns DataType
	 *     Class returns DataType
	 *     FirstOrderClassOrDataType returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns DerivationConstraint
	 *     ConstraintDeclaration returns DerivationConstraint
	 *     DerivationConstraint returns DerivationConstraint
	 *
	 * Constraint:
	 *     (classContext=[Class|ID] featureContext=[Feature|ID] typename=TypeLiteralExpression expression=OclExpression)
	 */
	protected void sequence_DerivationConstraint(ISerializationContext context, DerivationConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.CONSTRAINT__CLASS_CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.CONSTRAINT__CLASS_CONTEXT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.DERIVATION_CONSTRAINT__FEATURE_CONTEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.DERIVATION_CONSTRAINT__FEATURE_CONTEXT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.DERIVATION_CONSTRAINT__TYPENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.DERIVATION_CONSTRAINT__TYPENAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.CONSTRAINT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.CONSTRAINT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDerivationConstraintAccess().getClassContextClassIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ModelPackage.Literals.CONSTRAINT__CLASS_CONTEXT, false));
		feeder.accept(grammarAccess.getDerivationConstraintAccess().getFeatureContextFeatureIDTerminalRuleCall_3_0_1(), semanticObject.eGet(ModelPackage.Literals.DERIVATION_CONSTRAINT__FEATURE_CONTEXT, false));
		feeder.accept(grammarAccess.getDerivationConstraintAccess().getTypenameTypeLiteralExpressionParserRuleCall_5_0(), semanticObject.getTypename());
		feeder.accept(grammarAccess.getDerivationConstraintAccess().getExpressionOclExpressionParserRuleCall_8_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns DotOperation
	 *     DotOperation returns DotOperation
	 *
	 * Constraint:
	 *     right=VariableExpression
	 */
	protected void sequence_DotOperation(ISerializationContext context, DotOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.DOT_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.DOT_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDotOperationAccess().getRightVariableExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns FirstOrderClass
	 *     EntityDeclaration returns FirstOrderClass
	 *     Class returns FirstOrderClass
	 *     FirstOrderClassOrDataType returns FirstOrderClass
	 *     ClassIntoOrderedOrOrderless returns FirstOrderClass
	 *     OrderedClass returns FirstOrderClass
	 *     FirstOrderClass returns FirstOrderClass
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_FirstOrderClass(ISerializationContext context, FirstOrderClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns GeneralizationSet
	 *     GeneralizationSet returns GeneralizationSet
	 *
	 * Constraint:
	 *     (
	 *         (isDisjoint?='disjoint' | isComplete?='complete')* 
	 *         name=ID? 
	 *         general=[Class|QualifiedName] 
	 *         categorizer=[HigherOrderClass|QualifiedName]? 
	 *         specifics+=[Class|QualifiedName] 
	 *         specifics+=[Class|QualifiedName]+
	 *     )
	 */
	protected void sequence_GeneralizationSet(ISerializationContext context, GeneralizationSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns HighOrderClass
	 *     EntityDeclaration returns HighOrderClass
	 *     Class returns HighOrderClass
	 *     HigherOrderClass returns HighOrderClass
	 *     ClassIntoOrderedOrOrderless returns HighOrderClass
	 *     OrderedClass returns HighOrderClass
	 *     HighOrderClass returns HighOrderClass
	 *
	 * Constraint:
	 *     (
	 *         order=INT 
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (subordinators+=[HigherOrderClass|QualifiedName] subordinators+=[HigherOrderClass|QualifiedName]*)? 
	 *         ((categorizationType=CategorizationType categorizedClass=[Class|QualifiedName]) | powertypeOf=[Class|QualifiedName])? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_HighOrderClass(ISerializationContext context, HighOrderClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IfExpression
	 *     IfExpression returns IfExpression
	 *     TermExpression returns IfExpression
	 *
	 * Constraint:
	 *     (condition=OclExpression thenExpression=OclExpression elseExpression=OclExpression)
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__THEN_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__THEN_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__ELSE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__ELSE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfExpressionAccess().getConditionOclExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfExpressionAccess().getThenExpressionOclExpressionParserRuleCall_3_0(), semanticObject.getThenExpression());
		feeder.accept(grammarAccess.getIfExpressionAccess().getElseExpressionOclExpressionParserRuleCall_5_0(), semanticObject.getElseExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns ImpliesExpression
	 *     ImpliesExpression returns ImpliesExpression
	 *     TermExpression returns ImpliesExpression
	 *
	 * Constraint:
	 *     (left=XorExpression right+=XorExpression*)
	 */
	protected void sequence_ImpliesExpression(ISerializationContext context, ImpliesExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *     ModelElement returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns Individual
	 *     EntityDeclaration returns Individual
	 *     Individual returns Individual
	 *
	 * Constraint:
	 *     (name=ID classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]* assignments+=FeatureAssignment*)
	 */
	protected void sequence_Individual(ISerializationContext context, Individual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns InvariantConstraint
	 *     ConstraintDeclaration returns InvariantConstraint
	 *     InvariantConstraint returns InvariantConstraint
	 *
	 * Constraint:
	 *     (contextAlias=ID? classContext=[Class|ID] invariantAlias=ID? expression=OclExpression)
	 */
	protected void sequence_InvariantConstraint(ISerializationContext context, InvariantConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns LetExpression
	 *     LetExpression returns LetExpression
	 *     TermExpression returns LetExpression
	 *
	 * Constraint:
	 *     (variables+=VariableDeclaration variables+=VariableDeclaration* inExpression=OclExpression)
	 */
	protected void sequence_LetExpression(ISerializationContext context, LetExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=QualifiedName (includes+=[Model|QualifiedName] | elements+=ModelElement)*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|QualifiedName] 
	 *         (
	 *             (literalValues+=Literal literalValues+=Literal*) | 
	 *             (datatypeValues+=[Individual|QualifiedName] datatypeValues+=[Individual|QualifiedName]*) | 
	 *             (unnamedValues+=UnnamedIndividual unnamedValues+=UnnamedIndividual*)
	 *         )
	 *     )
	 */
	protected void sequence_MultipleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns AttributeAssignment
	 *     FeatureAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         (attribute=[Attribute|QualifiedName] (literalValues+=Literal | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)) | 
	 *         (
	 *             attribute=[Attribute|QualifiedName] 
	 *             (
	 *                 (literalValues+=Literal literalValues+=Literal*) | 
	 *                 (datatypeValues+=[Individual|QualifiedName] datatypeValues+=[Individual|QualifiedName]*) | 
	 *                 (unnamedValues+=UnnamedIndividual unnamedValues+=UnnamedIndividual*)
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_MultipleAttributeAssignment_SingleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleReferenceAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName] values+=[EntityDeclaration|QualifiedName]*)
	 */
	protected void sequence_MultipleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns ReferenceAssignment
	 *     FeatureAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (
	 *         (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName]) | 
	 *         (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName] values+=[EntityDeclaration|QualifiedName]*)
	 *     )
	 */
	protected void sequence_MultipleReferenceAssignment_SingleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleSimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|QualifiedName] 
	 *         (
	 *             (literalValues+=Literal literalValues+=Literal*) | 
	 *             (datatypeValues+=[Individual|QualifiedName] datatypeValues+=[Individual|QualifiedName]*) | 
	 *             (unnamedValues+=UnnamedIndividual unnamedValues+=UnnamedIndividual*)
	 *         )
	 *     )
	 */
	protected void sequence_MultipleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         (attribute=[Attribute|QualifiedName] (literalValues+=Literal | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)) | 
	 *         (
	 *             attribute=[Attribute|QualifiedName] 
	 *             (
	 *                 (literalValues+=Literal literalValues+=Literal*) | 
	 *                 (datatypeValues+=[Individual|QualifiedName] datatypeValues+=[Individual|QualifiedName]*) | 
	 *                 (unnamedValues+=UnnamedIndividual unnamedValues+=UnnamedIndividual*)
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_MultipleSimpleAttributeAssignment_SingleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicationExpression returns MultiplicationExpression
	 *
	 * Constraint:
	 *     (left=UnaryExpression right+=UnaryExpression*)
	 */
	protected void sequence_MultiplicationExpression(ISerializationContext context, MultiplicationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns NullLiteralExpression
	 *     LiteralExpression returns NullLiteralExpression
	 *     PrimitiveLiteralExpression returns NullLiteralExpression
	 *     NullLiteralExpression returns NullLiteralExpression
	 *
	 * Constraint:
	 *     nullSymbol='null'
	 */
	protected void sequence_NullLiteralExpression(ISerializationContext context, NullLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NULL_LITERAL_EXPRESSION__NULL_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NULL_LITERAL_EXPRESSION__NULL_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullLiteralExpressionAccess().getNullSymbolNullKeyword_0(), semanticObject.getNullSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns NumberLiteralExpression
	 *     LiteralExpression returns NumberLiteralExpression
	 *     PrimitiveLiteralExpression returns NumberLiteralExpression
	 *     NumberLiteralExpression returns NumberLiteralExpression
	 *
	 * Constraint:
	 *     numberSymbol=NUMBER_LITERAL
	 */
	protected void sequence_NumberLiteralExpression(ISerializationContext context, NumberLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NUMBER_LITERAL_EXPRESSION__NUMBER_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NUMBER_LITERAL_EXPRESSION__NUMBER_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralExpressionAccess().getNumberSymbolNUMBER_LITERALParserRuleCall_0(), semanticObject.getNumberSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns OclTypeName
	 *     LiteralExpression returns OclTypeName
	 *     TypeLiteralExpression returns OclTypeName
	 *     OclTypeName returns OclTypeName
	 *
	 * Constraint:
	 *     (typename='OclAny' | typename='OclVoid')
	 */
	protected void sequence_OclTypeName(ISerializationContext context, OclTypeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrExpression returns OrExpression
	 *
	 * Constraint:
	 *     (left=AndExpression right+=AndExpression*)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns OrderlessClass
	 *     EntityDeclaration returns OrderlessClass
	 *     Class returns OrderlessClass
	 *     HigherOrderClass returns OrderlessClass
	 *     ClassIntoOrderedOrOrderless returns OrderlessClass
	 *     OrderlessClass returns OrderlessClass
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (subordinators+=[HigherOrderClass|QualifiedName] subordinators+=[HigherOrderClass|QualifiedName]*)? 
	 *         ((categorizationType=CategorizationType categorizedClass=[Class|QualifiedName]) | powertypeOf=[Class|QualifiedName])? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_OrderlessClass(ISerializationContext context, OrderlessClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns PrimitiveTypeName
	 *     LiteralExpression returns PrimitiveTypeName
	 *     TypeLiteralExpression returns PrimitiveTypeName
	 *     PrimitiveTypeName returns PrimitiveTypeName
	 *
	 * Constraint:
	 *     (typename='Boolean' | typename='Number' | typename='String')
	 */
	protected void sequence_PrimitiveTypeName(ISerializationContext context, PrimitiveTypeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns Reference
	 *     Feature returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         _type=[Class|QualifiedName] 
	 *         (subsetOf+=[Reference|QualifiedName] subsetOf+=[Reference|QualifiedName]*)? 
	 *         oppositeTo=[Reference|QualifiedName]?
	 *     )
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns RegularityAttribute
	 *     Feature returns RegularityAttribute
	 *     Attribute returns RegularityAttribute
	 *     RegularityAttribute returns RegularityAttribute
	 *     FeatureIntoRegularityFeature returns RegularityAttribute
	 *     RegularityFeature returns RegularityAttribute
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         (primitiveType=PrimitiveType | _type=[DataType|QualifiedName]) 
	 *         (subsetOf+=[Attribute|QualifiedName] subsetOf+=[Attribute|QualifiedName]*)? 
	 *         regularityType=RegularityFeatureType 
	 *         regulates=[Attribute|QualifiedName]
	 *     )
	 */
	protected void sequence_RegularityAttribute(ISerializationContext context, RegularityAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns RegularityReference
	 *     Feature returns RegularityReference
	 *     Reference returns RegularityReference
	 *     RegularityReference returns RegularityReference
	 *     FeatureIntoRegularityFeature returns RegularityReference
	 *     RegularityFeature returns RegularityReference
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         _type=[Class|QualifiedName] 
	 *         (subsetOf+=[Reference|QualifiedName] subsetOf+=[Reference|QualifiedName]*)? 
	 *         oppositeTo=[Reference|QualifiedName]? 
	 *         regularityType=RegularityFeatureType 
	 *         regulates=[Reference|QualifiedName]
	 *     )
	 */
	protected void sequence_RegularityReference(ISerializationContext context, RegularityReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (left=AdditionExpression right+=RelationalOperation*)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalOperation returns RelationalOperation
	 *
	 * Constraint:
	 *     (operator=RelationalOperator right=AdditionExpression)
	 */
	protected void sequence_RelationalOperation(ISerializationContext context, RelationalOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.RELATIONAL_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.RELATIONAL_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.RELATIONAL_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.RELATIONAL_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalOperationAccess().getOperatorRelationalOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRelationalOperationAccess().getRightAdditionExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SingleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (attribute=[Attribute|QualifiedName] (literalValues+=Literal | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual))
	 */
	protected void sequence_SingleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleReferenceAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName])
	 */
	protected void sequence_SingleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleSimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (attribute=[Attribute|QualifiedName] (literalValues+=Literal | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual))
	 */
	protected void sequence_SingleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns StringLiteralExpression
	 *     LiteralExpression returns StringLiteralExpression
	 *     PrimitiveLiteralExpression returns StringLiteralExpression
	 *     StringLiteralExpression returns StringLiteralExpression
	 *
	 * Constraint:
	 *     stringSymbol=STRING
	 */
	protected void sequence_StringLiteralExpression(ISerializationContext context, StringLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.STRING_LITERAL_EXPRESSION__STRING_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.STRING_LITERAL_EXPRESSION__STRING_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpressionAccess().getStringSymbolSTRINGTerminalRuleCall_0(), semanticObject.getStringSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns TupleLiteralExpression
	 *     LiteralExpression returns TupleLiteralExpression
	 *     TupleLiteralExpression returns TupleLiteralExpression
	 *
	 * Constraint:
	 *     (variables+=ID variables+=ID*)
	 */
	protected void sequence_TupleLiteralExpression(ISerializationContext context, TupleLiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns TupleTypeName
	 *     LiteralExpression returns TupleTypeName
	 *     TypeLiteralExpression returns TupleTypeName
	 *     TupleTypeName returns TupleTypeName
	 *
	 * Constraint:
	 *     (typename='Tuple' (variables+=ID variables+=ID*)?)
	 */
	protected void sequence_TupleTypeName(ISerializationContext context, TupleTypeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (operator=UnaryOperator? right=TermExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BuiltInOperation returns UnaryIteration
	 *     UnaryIteration returns UnaryIteration
	 *
	 * Constraint:
	 *     (iterator=UnaryIterator variables+=ID? body=OclExpression)
	 */
	protected void sequence_UnaryIteration(ISerializationContext context, UnaryIteration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BuiltInOperation returns UnarySetOperation
	 *     UnarySetOperation returns UnarySetOperation
	 *
	 * Constraint:
	 *     operator=UnarySetOperator
	 */
	protected void sequence_UnarySetOperation(ISerializationContext context, UnarySetOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.UNARY_SET_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.UNARY_SET_OPERATION__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnarySetOperationAccess().getOperatorUnarySetOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnnamedIndividual returns Individual
	 *
	 * Constraint:
	 *     assignments+=SimpleAttributeAssignment*
	 */
	protected void sequence_UnnamedIndividual(ISerializationContext context, Individual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (variableName=ID variableType=TypeLiteralExpression initialValue=LiteralExpression)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__VARIABLE_NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__VARIABLE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__VARIABLE_TYPE));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__INITIAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__INITIAL_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getVariableNameIDTerminalRuleCall_0_0(), semanticObject.getVariableName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getVariableTypeTypeLiteralExpressionParserRuleCall_2_0(), semanticObject.getVariableType());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getInitialValueLiteralExpressionParserRuleCall_4_0(), semanticObject.getInitialValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableExpression returns VariableExpression
	 *
	 * Constraint:
	 *     (referringVariable=ID | referringVariable='self')
	 */
	protected void sequence_VariableExpression(ISerializationContext context, VariableExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XorExpression returns XorExpression
	 *
	 * Constraint:
	 *     (left=OrExpression right+=OrExpression*)
	 */
	protected void sequence_XorExpression(ISerializationContext context, XorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
