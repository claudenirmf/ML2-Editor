/*
 * generated by Xtext 2.21.0
 */
package br.ufes.inf.nemo.ml2.serializer;

import br.ufes.inf.nemo.ml2.model.Attribute;
import br.ufes.inf.nemo.ml2.model.AttributeAssignment;
import br.ufes.inf.nemo.ml2.model.DataType;
import br.ufes.inf.nemo.ml2.model.FirstOrderClass;
import br.ufes.inf.nemo.ml2.model.GeneralizationSet;
import br.ufes.inf.nemo.ml2.model.HighOrderClass;
import br.ufes.inf.nemo.ml2.model.Import;
import br.ufes.inf.nemo.ml2.model.Individual;
import br.ufes.inf.nemo.ml2.model.Model;
import br.ufes.inf.nemo.ml2.model.ModelPackage;
import br.ufes.inf.nemo.ml2.model.OrderlessClass;
import br.ufes.inf.nemo.ml2.model.Reference;
import br.ufes.inf.nemo.ml2.model.ReferenceAssignment;
import br.ufes.inf.nemo.ml2.model.RegularityAttribute;
import br.ufes.inf.nemo.ml2.model.RegularityReference;
import br.ufes.inf.nemo.ml2.services.ML2GrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractML2SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ML2GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ModelPackage.ATTRIBUTE_ASSIGNMENT:
				if (rule == grammarAccess.getMultipleAttributeAssignmentRule()) {
					sequence_MultipleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getModelElementRule()
						|| rule == grammarAccess.getFeatureAssignmentRule()) {
					sequence_MultipleAttributeAssignment_SingleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultipleSimpleAttributeAssignmentRule()) {
					sequence_MultipleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleAttributeAssignmentRule()) {
					sequence_MultipleSimpleAttributeAssignment_SingleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleAttributeAssignmentRule()) {
					sequence_SingleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleSimpleAttributeAssignmentRule()) {
					sequence_SingleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case ModelPackage.FIRST_ORDER_CLASS:
				sequence_FirstOrderClass(context, (FirstOrderClass) semanticObject); 
				return; 
			case ModelPackage.GENERALIZATION_SET:
				sequence_GeneralizationSet(context, (GeneralizationSet) semanticObject); 
				return; 
			case ModelPackage.HIGH_ORDER_CLASS:
				sequence_HighOrderClass(context, (HighOrderClass) semanticObject); 
				return; 
			case ModelPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ModelPackage.INDIVIDUAL:
				if (rule == grammarAccess.getModelElementRule()
						|| rule == grammarAccess.getEntityDeclarationRule()
						|| rule == grammarAccess.getIndividualRule()) {
					sequence_Individual(context, (Individual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnnamedIndividualRule()) {
					sequence_UnnamedIndividual(context, (Individual) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ModelPackage.ORDERLESS_CLASS:
				sequence_OrderlessClass(context, (OrderlessClass) semanticObject); 
				return; 
			case ModelPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case ModelPackage.REFERENCE_ASSIGNMENT:
				if (rule == grammarAccess.getMultipleReferenceAssignmentRule()) {
					sequence_MultipleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getModelElementRule()
						|| rule == grammarAccess.getFeatureAssignmentRule()) {
					sequence_MultipleReferenceAssignment_SingleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleReferenceAssignmentRule()) {
					sequence_SingleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.REGULARITY_ATTRIBUTE:
				sequence_RegularityAttribute(context, (RegularityAttribute) semanticObject); 
				return; 
			case ModelPackage.REGULARITY_REFERENCE:
				sequence_RegularityReference(context, (RegularityReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ModelElement returns Attribute
	 *     Feature returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         (primitiveType=PrimitiveType | _type=[DataType|QualifiedName]) 
	 *         (subsetOf+=[Attribute|QualifiedName] subsetOf+=[Attribute|QualifiedName]*)?
	 *     )
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns DataType
	 *     EntityDeclaration returns DataType
	 *     Class returns DataType
	 *     FirstOrderClassOrDataType returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns FirstOrderClass
	 *     EntityDeclaration returns FirstOrderClass
	 *     Class returns FirstOrderClass
	 *     FirstOrderClassOrDataType returns FirstOrderClass
	 *     ClassIntoOrderedOrOrderless returns FirstOrderClass
	 *     OrderedClass returns FirstOrderClass
	 *     FirstOrderClass returns FirstOrderClass
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_FirstOrderClass(ISerializationContext context, FirstOrderClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns GeneralizationSet
	 *     GeneralizationSet returns GeneralizationSet
	 *
	 * Constraint:
	 *     (
	 *         (isDisjoint?='disjoint' | isComplete?='complete')* 
	 *         name=ID? 
	 *         general=[Class|QualifiedName] 
	 *         categorizer=[HigherOrderClass|QualifiedName]? 
	 *         specifics+=[Class|QualifiedName] 
	 *         specifics+=[Class|QualifiedName]+
	 *     )
	 */
	protected void sequence_GeneralizationSet(ISerializationContext context, GeneralizationSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns HighOrderClass
	 *     EntityDeclaration returns HighOrderClass
	 *     Class returns HighOrderClass
	 *     HigherOrderClass returns HighOrderClass
	 *     ClassIntoOrderedOrOrderless returns HighOrderClass
	 *     OrderedClass returns HighOrderClass
	 *     HighOrderClass returns HighOrderClass
	 *
	 * Constraint:
	 *     (
	 *         order=INT 
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (subordinators+=[HigherOrderClass|QualifiedName] subordinators+=[HigherOrderClass|QualifiedName]*)? 
	 *         ((categorizationType=CategorizationType categorizedClass=[Class|QualifiedName]) | powertypeOf=[Class|QualifiedName])? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_HighOrderClass(ISerializationContext context, HighOrderClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *     ModelElement returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns Individual
	 *     EntityDeclaration returns Individual
	 *     Individual returns Individual
	 *
	 * Constraint:
	 *     (name=ID classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]* assignments+=FeatureAssignment*)
	 */
	protected void sequence_Individual(ISerializationContext context, Individual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=QualifiedName (includes+=[Model|QualifiedName] | elements+=ModelElement)*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|QualifiedName] 
	 *         (
	 *             (literalValues+=Literal literalValues+=Literal*) | 
	 *             (datatypeValues+=[Individual|QualifiedName] datatypeValues+=[Individual|QualifiedName]*) | 
	 *             (unnamedValues+=UnnamedIndividual unnamedValues+=UnnamedIndividual*)
	 *         )
	 *     )
	 */
	protected void sequence_MultipleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns AttributeAssignment
	 *     FeatureAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         (attribute=[Attribute|QualifiedName] (literalValues+=Literal | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)) | 
	 *         (
	 *             attribute=[Attribute|QualifiedName] 
	 *             (
	 *                 (literalValues+=Literal literalValues+=Literal*) | 
	 *                 (datatypeValues+=[Individual|QualifiedName] datatypeValues+=[Individual|QualifiedName]*) | 
	 *                 (unnamedValues+=UnnamedIndividual unnamedValues+=UnnamedIndividual*)
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_MultipleAttributeAssignment_SingleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleReferenceAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName] values+=[EntityDeclaration|QualifiedName]*)
	 */
	protected void sequence_MultipleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns ReferenceAssignment
	 *     FeatureAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (
	 *         (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName]) | 
	 *         (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName] values+=[EntityDeclaration|QualifiedName]*)
	 *     )
	 */
	protected void sequence_MultipleReferenceAssignment_SingleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleSimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|QualifiedName] 
	 *         (
	 *             (literalValues+=Literal literalValues+=Literal*) | 
	 *             (datatypeValues+=[Individual|QualifiedName] datatypeValues+=[Individual|QualifiedName]*) | 
	 *             (unnamedValues+=UnnamedIndividual unnamedValues+=UnnamedIndividual*)
	 *         )
	 *     )
	 */
	protected void sequence_MultipleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         (attribute=[Attribute|QualifiedName] (literalValues+=Literal | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)) | 
	 *         (
	 *             attribute=[Attribute|QualifiedName] 
	 *             (
	 *                 (literalValues+=Literal literalValues+=Literal*) | 
	 *                 (datatypeValues+=[Individual|QualifiedName] datatypeValues+=[Individual|QualifiedName]*) | 
	 *                 (unnamedValues+=UnnamedIndividual unnamedValues+=UnnamedIndividual*)
	 *             )
	 *         )
	 *     )
	 */
	protected void sequence_MultipleSimpleAttributeAssignment_SingleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns OrderlessClass
	 *     EntityDeclaration returns OrderlessClass
	 *     Class returns OrderlessClass
	 *     HigherOrderClass returns OrderlessClass
	 *     ClassIntoOrderedOrOrderless returns OrderlessClass
	 *     OrderlessClass returns OrderlessClass
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (subordinators+=[HigherOrderClass|QualifiedName] subordinators+=[HigherOrderClass|QualifiedName]*)? 
	 *         ((categorizationType=CategorizationType categorizedClass=[Class|QualifiedName]) | powertypeOf=[Class|QualifiedName])? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_OrderlessClass(ISerializationContext context, OrderlessClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns Reference
	 *     Feature returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         _type=[Class|QualifiedName] 
	 *         (subsetOf+=[Reference|QualifiedName] subsetOf+=[Reference|QualifiedName]*)? 
	 *         oppositeTo=[Reference|QualifiedName]?
	 *     )
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns RegularityAttribute
	 *     Feature returns RegularityAttribute
	 *     Attribute returns RegularityAttribute
	 *     RegularityAttribute returns RegularityAttribute
	 *     FeatureIntoRegularityFeature returns RegularityAttribute
	 *     RegularityFeature returns RegularityAttribute
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         (primitiveType=PrimitiveType | _type=[DataType|QualifiedName]) 
	 *         (subsetOf+=[Attribute|QualifiedName] subsetOf+=[Attribute|QualifiedName]*)? 
	 *         regularityType=RegularityFeatureType 
	 *         regulates=[Attribute|QualifiedName]
	 *     )
	 */
	protected void sequence_RegularityAttribute(ISerializationContext context, RegularityAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns RegularityReference
	 *     Feature returns RegularityReference
	 *     Reference returns RegularityReference
	 *     RegularityReference returns RegularityReference
	 *     FeatureIntoRegularityFeature returns RegularityReference
	 *     RegularityFeature returns RegularityReference
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         _type=[Class|QualifiedName] 
	 *         (subsetOf+=[Reference|QualifiedName] subsetOf+=[Reference|QualifiedName]*)? 
	 *         oppositeTo=[Reference|QualifiedName]? 
	 *         regularityType=RegularityFeatureType 
	 *         regulates=[Reference|QualifiedName]
	 *     )
	 */
	protected void sequence_RegularityReference(ISerializationContext context, RegularityReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (attribute=[Attribute|QualifiedName] (literalValues+=Literal | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual))
	 */
	protected void sequence_SingleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleReferenceAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName])
	 */
	protected void sequence_SingleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleSimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (attribute=[Attribute|QualifiedName] (literalValues+=Literal | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual))
	 */
	protected void sequence_SingleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnnamedIndividual returns Individual
	 *
	 * Constraint:
	 *     assignments+=SimpleAttributeAssignment*
	 */
	protected void sequence_UnnamedIndividual(ISerializationContext context, Individual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
