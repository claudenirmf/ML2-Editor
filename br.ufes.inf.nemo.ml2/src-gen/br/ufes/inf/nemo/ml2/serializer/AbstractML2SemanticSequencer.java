/*
 * generated by Xtext 2.21.0
 */
package br.ufes.inf.nemo.ml2.serializer;

import br.ufes.inf.nemo.ml2.model.AdditionExpression;
import br.ufes.inf.nemo.ml2.model.AdditionOperation;
import br.ufes.inf.nemo.ml2.model.AndExpression;
import br.ufes.inf.nemo.ml2.model.Attribute;
import br.ufes.inf.nemo.ml2.model.AttributeAssignment;
import br.ufes.inf.nemo.ml2.model.BinaryNumberOperation;
import br.ufes.inf.nemo.ml2.model.BinarySetOperation;
import br.ufes.inf.nemo.ml2.model.BooleanLiteralExpression;
import br.ufes.inf.nemo.ml2.model.CallExpression;
import br.ufes.inf.nemo.ml2.model.ComparisonExpression;
import br.ufes.inf.nemo.ml2.model.ComparisonOperation;
import br.ufes.inf.nemo.ml2.model.DataType;
import br.ufes.inf.nemo.ml2.model.DerivationConstraint;
import br.ufes.inf.nemo.ml2.model.FirstOrderClass;
import br.ufes.inf.nemo.ml2.model.GeneralizationSet;
import br.ufes.inf.nemo.ml2.model.HighOrderClass;
import br.ufes.inf.nemo.ml2.model.IfExpression;
import br.ufes.inf.nemo.ml2.model.ImpliesExpression;
import br.ufes.inf.nemo.ml2.model.Import;
import br.ufes.inf.nemo.ml2.model.Individual;
import br.ufes.inf.nemo.ml2.model.InvariantConstraint;
import br.ufes.inf.nemo.ml2.model.LetExpression;
import br.ufes.inf.nemo.ml2.model.Model;
import br.ufes.inf.nemo.ml2.model.ModelPackage;
import br.ufes.inf.nemo.ml2.model.MultiaryIteration;
import br.ufes.inf.nemo.ml2.model.MultiplicationExpression;
import br.ufes.inf.nemo.ml2.model.MultiplicationOperation;
import br.ufes.inf.nemo.ml2.model.NavigationSource;
import br.ufes.inf.nemo.ml2.model.NullLiteralExpression;
import br.ufes.inf.nemo.ml2.model.NumberLiteralExpression;
import br.ufes.inf.nemo.ml2.model.OrExpression;
import br.ufes.inf.nemo.ml2.model.OrderlessClass;
import br.ufes.inf.nemo.ml2.model.PrimitiveTypeLiteral;
import br.ufes.inf.nemo.ml2.model.Reference;
import br.ufes.inf.nemo.ml2.model.ReferenceAssignment;
import br.ufes.inf.nemo.ml2.model.RegularityAttribute;
import br.ufes.inf.nemo.ml2.model.RegularityReference;
import br.ufes.inf.nemo.ml2.model.RelationalExpression;
import br.ufes.inf.nemo.ml2.model.RelationalOperation;
import br.ufes.inf.nemo.ml2.model.SetLiteralExpression;
import br.ufes.inf.nemo.ml2.model.SetTypeLiteral;
import br.ufes.inf.nemo.ml2.model.StringLiteralExpression;
import br.ufes.inf.nemo.ml2.model.TypeOperation;
import br.ufes.inf.nemo.ml2.model.UnaryExpression;
import br.ufes.inf.nemo.ml2.model.UnaryIteration;
import br.ufes.inf.nemo.ml2.model.UnaryNumberOperation;
import br.ufes.inf.nemo.ml2.model.UnarySetOperation;
import br.ufes.inf.nemo.ml2.model.UserDefinedTypeLiteral;
import br.ufes.inf.nemo.ml2.model.VariableDeclaration;
import br.ufes.inf.nemo.ml2.model.VariableExpression;
import br.ufes.inf.nemo.ml2.model.XorExpression;
import br.ufes.inf.nemo.ml2.services.ML2GrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractML2SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ML2GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelPackage.ADDITION_EXPRESSION:
				sequence_AdditionExpression(context, (AdditionExpression) semanticObject); 
				return; 
			case ModelPackage.ADDITION_OPERATION:
				sequence_AdditionOperation(context, (AdditionOperation) semanticObject); 
				return; 
			case ModelPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case ModelPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case ModelPackage.ATTRIBUTE_ASSIGNMENT:
				if (rule == grammarAccess.getMultipleAttributeAssignmentRule()) {
					sequence_MultipleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAllModelElementsRule()
						|| rule == grammarAccess.getFeatureAssignmentRule()) {
					sequence_MultipleAttributeAssignment_SingleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultipleSimpleAttributeAssignmentRule()) {
					sequence_MultipleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleAttributeAssignmentRule()) {
					sequence_MultipleSimpleAttributeAssignment_SingleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleAttributeAssignmentRule()) {
					sequence_SingleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleSimpleAttributeAssignmentRule()) {
					sequence_SingleSimpleAttributeAssignment(context, (AttributeAssignment) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.BINARY_NUMBER_OPERATION:
				sequence_BinaryNumberOperation(context, (BinaryNumberOperation) semanticObject); 
				return; 
			case ModelPackage.BINARY_SET_OPERATION:
				sequence_BinarySetOperation(context, (BinarySetOperation) semanticObject); 
				return; 
			case ModelPackage.BOOLEAN_LITERAL_EXPRESSION:
				sequence_BooleanLiteralExpression(context, (BooleanLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.CALL_EXPRESSION:
				sequence_CallExpression(context, (CallExpression) semanticObject); 
				return; 
			case ModelPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case ModelPackage.COMPARISON_OPERATION:
				sequence_ComparisonOperation(context, (ComparisonOperation) semanticObject); 
				return; 
			case ModelPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case ModelPackage.DERIVATION_CONSTRAINT:
				sequence_DerivationConstraint(context, (DerivationConstraint) semanticObject); 
				return; 
			case ModelPackage.FIRST_ORDER_CLASS:
				sequence_FirstOrderClass(context, (FirstOrderClass) semanticObject); 
				return; 
			case ModelPackage.GENERALIZATION_SET:
				sequence_GeneralizationSet(context, (GeneralizationSet) semanticObject); 
				return; 
			case ModelPackage.HIGH_ORDER_CLASS:
				sequence_HighOrderClass(context, (HighOrderClass) semanticObject); 
				return; 
			case ModelPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case ModelPackage.IMPLIES_EXPRESSION:
				sequence_ImpliesExpression(context, (ImpliesExpression) semanticObject); 
				return; 
			case ModelPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ModelPackage.INDIVIDUAL:
				if (rule == grammarAccess.getModelElementRule()
						|| rule == grammarAccess.getAllModelElementsRule()
						|| rule == grammarAccess.getEntityDeclarationRule()
						|| rule == grammarAccess.getIndividualRule()) {
					sequence_Individual(context, (Individual) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnnamedIndividualRule()) {
					sequence_UnnamedIndividual(context, (Individual) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.INVARIANT_CONSTRAINT:
				sequence_InvariantConstraint(context, (InvariantConstraint) semanticObject); 
				return; 
			case ModelPackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case ModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ModelPackage.MULTIARY_ITERATION:
				sequence_MultiaryIteration(context, (MultiaryIteration) semanticObject); 
				return; 
			case ModelPackage.MULTIPLICATION_EXPRESSION:
				sequence_MultiplicationExpression(context, (MultiplicationExpression) semanticObject); 
				return; 
			case ModelPackage.MULTIPLICATION_OPERATION:
				sequence_MultiplicationOperation(context, (MultiplicationOperation) semanticObject); 
				return; 
			case ModelPackage.NAVIGATION_SOURCE:
				sequence_NavigationSource(context, (NavigationSource) semanticObject); 
				return; 
			case ModelPackage.NULL_LITERAL_EXPRESSION:
				sequence_NullLiteralExpression(context, (NullLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.NUMBER_LITERAL_EXPRESSION:
				sequence_NumberLiteralExpression(context, (NumberLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case ModelPackage.ORDERLESS_CLASS:
				sequence_OrderlessClass(context, (OrderlessClass) semanticObject); 
				return; 
			case ModelPackage.PRIMITIVE_TYPE_LITERAL:
				sequence_PrimitiveTypeLiteral(context, (PrimitiveTypeLiteral) semanticObject); 
				return; 
			case ModelPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case ModelPackage.REFERENCE_ASSIGNMENT:
				if (rule == grammarAccess.getMultipleReferenceAssignmentRule()) {
					sequence_MultipleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAllModelElementsRule()
						|| rule == grammarAccess.getFeatureAssignmentRule()) {
					sequence_MultipleReferenceAssignment_SingleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSingleReferenceAssignmentRule()) {
					sequence_SingleReferenceAssignment(context, (ReferenceAssignment) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.REGULARITY_ATTRIBUTE:
				sequence_RegularityAttribute(context, (RegularityAttribute) semanticObject); 
				return; 
			case ModelPackage.REGULARITY_REFERENCE:
				sequence_RegularityReference(context, (RegularityReference) semanticObject); 
				return; 
			case ModelPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case ModelPackage.RELATIONAL_OPERATION:
				sequence_RelationalOperation(context, (RelationalOperation) semanticObject); 
				return; 
			case ModelPackage.SET_LITERAL_EXPRESSION:
				sequence_SetLiteralExpression(context, (SetLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.SET_TYPE_LITERAL:
				sequence_SetTypeLiteral(context, (SetTypeLiteral) semanticObject); 
				return; 
			case ModelPackage.STRING_LITERAL_EXPRESSION:
				sequence_StringLiteralExpression(context, (StringLiteralExpression) semanticObject); 
				return; 
			case ModelPackage.TYPE_OPERATION:
				sequence_TypeOperation(context, (TypeOperation) semanticObject); 
				return; 
			case ModelPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case ModelPackage.UNARY_ITERATION:
				sequence_UnaryIteration(context, (UnaryIteration) semanticObject); 
				return; 
			case ModelPackage.UNARY_NUMBER_OPERATION:
				sequence_UnaryNumberOperation(context, (UnaryNumberOperation) semanticObject); 
				return; 
			case ModelPackage.UNARY_SET_OPERATION:
				sequence_UnarySetOperation(context, (UnarySetOperation) semanticObject); 
				return; 
			case ModelPackage.USER_DEFINED_TYPE_LITERAL:
				sequence_UserDefinedTypeLiteral(context, (UserDefinedTypeLiteral) semanticObject); 
				return; 
			case ModelPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case ModelPackage.VARIABLE_EXPRESSION:
				sequence_VariableExpression(context, (VariableExpression) semanticObject); 
				return; 
			case ModelPackage.XOR_EXPRESSION:
				sequence_XorExpression(context, (XorExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdditionExpression returns AdditionExpression
	 *
	 * Constraint:
	 *     (left=MultiplicationExpression right+=AdditionOperation*)
	 */
	protected void sequence_AdditionExpression(ISerializationContext context, AdditionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditionOperation returns AdditionOperation
	 *
	 * Constraint:
	 *     (operator=AdditionOperator right=MultiplicationExpression)
	 */
	protected void sequence_AdditionOperation(ISerializationContext context, AdditionOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ADDITION_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ADDITION_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ADDITION_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ADDITION_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionOperationAccess().getOperatorAdditionOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAdditionOperationAccess().getRightMultiplicationExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns AndExpression
	 *
	 * Constraint:
	 *     (left=ComparisonExpression right+=ComparisonExpression*)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllModelElements returns Attribute
	 *     Feature returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         (primitiveType=PrimitiveType | _type=[DataType|QualifiedName]) 
	 *         (subsetOf+=[Attribute|QualifiedName] subsetOf+=[Attribute|QualifiedName]*)?
	 *     )
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns BinaryNumberOperation
	 *     DotOperation returns BinaryNumberOperation
	 *     BinaryNumberOperation returns BinaryNumberOperation
	 *
	 * Constraint:
	 *     (operator=BinaryNumberOperator argument=OclExpression)
	 */
	protected void sequence_BinaryNumberOperation(ISerializationContext context, BinaryNumberOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_NUMBER_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_NUMBER_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_NUMBER_OPERATION__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_NUMBER_OPERATION__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryNumberOperationAccess().getOperatorBinaryNumberOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBinaryNumberOperationAccess().getArgumentOclExpressionParserRuleCall_2_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns BinarySetOperation
	 *     ArrowOperation returns BinarySetOperation
	 *     BinarySetOperation returns BinarySetOperation
	 *
	 * Constraint:
	 *     (operator=BinarySetOperator argument=OclExpression)
	 */
	protected void sequence_BinarySetOperation(ISerializationContext context, BinarySetOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_SET_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_SET_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BINARY_SET_OPERATION__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BINARY_SET_OPERATION__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinarySetOperationAccess().getOperatorBinarySetOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getBinarySetOperationAccess().getArgumentOclExpressionParserRuleCall_2_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns BooleanLiteralExpression
	 *     LiteralExpression returns BooleanLiteralExpression
	 *     PrimitiveLiteralExpression returns BooleanLiteralExpression
	 *     BooleanLiteralExpression returns BooleanLiteralExpression
	 *
	 * Constraint:
	 *     booleanSymbol=BOOLEAN_LITERAL
	 */
	protected void sequence_BooleanLiteralExpression(ISerializationContext context, BooleanLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__BOOLEAN_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__BOOLEAN_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralExpressionAccess().getBooleanSymbolBOOLEAN_LITERALParserRuleCall_0(), semanticObject.isBooleanSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns CallExpression
	 *     CallExpression returns CallExpression
	 *
	 * Constraint:
	 *     (left=NavigationSource right+=CallOperation*)
	 */
	protected void sequence_CallExpression(ISerializationContext context, CallExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComparisonExpression returns ComparisonExpression
	 *
	 * Constraint:
	 *     (left=RelationalExpression right+=ComparisonOperation*)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComparisonOperation returns ComparisonOperation
	 *
	 * Constraint:
	 *     (operator=ComparisonOperator right=RelationalExpression)
	 */
	protected void sequence_ComparisonOperation(ISerializationContext context, ComparisonOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COMPARISON_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COMPARISON_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.COMPARISON_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.COMPARISON_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperationAccess().getOperatorComparisonOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getComparisonOperationAccess().getRightRelationalExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns DataType
	 *     AllModelElements returns DataType
	 *     EntityDeclaration returns DataType
	 *     Class returns DataType
	 *     FirstOrderClassOrDataType returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns DerivationConstraint
	 *     ConstraintDeclaration returns DerivationConstraint
	 *     DerivationConstraint returns DerivationConstraint
	 *
	 * Constraint:
	 *     (classContext=[Class|ID] featureContext+=ID+ contextType=TypeLiteralExpression expression=OclExpression)
	 */
	protected void sequence_DerivationConstraint(ISerializationContext context, DerivationConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns FirstOrderClass
	 *     AllModelElements returns FirstOrderClass
	 *     EntityDeclaration returns FirstOrderClass
	 *     Class returns FirstOrderClass
	 *     FirstOrderClassOrDataType returns FirstOrderClass
	 *     ClassIntoOrderedOrOrderless returns FirstOrderClass
	 *     OrderedClass returns FirstOrderClass
	 *     FirstOrderClass returns FirstOrderClass
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_FirstOrderClass(ISerializationContext context, FirstOrderClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns GeneralizationSet
	 *     AllModelElements returns GeneralizationSet
	 *     GeneralizationSet returns GeneralizationSet
	 *
	 * Constraint:
	 *     (
	 *         (isDisjoint?='disjoint' | isComplete?='complete')* 
	 *         name=ID? 
	 *         general=[Class|QualifiedName] 
	 *         categorizer=[HigherOrderClass|QualifiedName]? 
	 *         specifics+=[Class|QualifiedName] 
	 *         specifics+=[Class|QualifiedName]+
	 *     )
	 */
	protected void sequence_GeneralizationSet(ISerializationContext context, GeneralizationSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns HighOrderClass
	 *     AllModelElements returns HighOrderClass
	 *     EntityDeclaration returns HighOrderClass
	 *     Class returns HighOrderClass
	 *     HigherOrderClass returns HighOrderClass
	 *     ClassIntoOrderedOrOrderless returns HighOrderClass
	 *     OrderedClass returns HighOrderClass
	 *     HighOrderClass returns HighOrderClass
	 *
	 * Constraint:
	 *     (
	 *         order=INT 
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (subordinators+=[HigherOrderClass|QualifiedName] subordinators+=[HigherOrderClass|QualifiedName]*)? 
	 *         ((categorizationType=CategorizationType categorizedClass=[Class|QualifiedName]) | powertypeOf=[Class|QualifiedName])? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_HighOrderClass(ISerializationContext context, HighOrderClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IfExpression
	 *     IfExpression returns IfExpression
	 *     TermExpression returns IfExpression
	 *
	 * Constraint:
	 *     (condition=OclExpression thenExpression=OclExpression elseExpression=OclExpression)
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__THEN_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__THEN_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IF_EXPRESSION__ELSE_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IF_EXPRESSION__ELSE_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfExpressionAccess().getConditionOclExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfExpressionAccess().getThenExpressionOclExpressionParserRuleCall_3_0(), semanticObject.getThenExpression());
		feeder.accept(grammarAccess.getIfExpressionAccess().getElseExpressionOclExpressionParserRuleCall_5_0(), semanticObject.getElseExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns ImpliesExpression
	 *     ImpliesExpression returns ImpliesExpression
	 *     TermExpression returns ImpliesExpression
	 *
	 * Constraint:
	 *     (left=XorExpression right+=XorExpression*)
	 */
	protected void sequence_ImpliesExpression(ISerializationContext context, ImpliesExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *     ModelElement returns Import
	 *     AllModelElements returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns Individual
	 *     AllModelElements returns Individual
	 *     EntityDeclaration returns Individual
	 *     Individual returns Individual
	 *
	 * Constraint:
	 *     (name=ID classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]* assignments+=FeatureAssignment*)
	 */
	protected void sequence_Individual(ISerializationContext context, Individual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns InvariantConstraint
	 *     ConstraintDeclaration returns InvariantConstraint
	 *     InvariantConstraint returns InvariantConstraint
	 *
	 * Constraint:
	 *     (classContext=[Class|ID] invariantAlias=ID? expression=OclExpression)
	 */
	protected void sequence_InvariantConstraint(ISerializationContext context, InvariantConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns LetExpression
	 *     LetExpression returns LetExpression
	 *     TermExpression returns LetExpression
	 *
	 * Constraint:
	 *     (variables+=VariableDeclaration variables+=VariableDeclaration* inExpression=OclExpression)
	 */
	protected void sequence_LetExpression(ISerializationContext context, LetExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=QualifiedName (includes+=[Model|QualifiedName] | elements+=ModelElement)*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns MultiaryIteration
	 *     ArrowOperation returns MultiaryIteration
	 *     MultiaryIteration returns MultiaryIteration
	 *
	 * Constraint:
	 *     (iterator=MultiaryIterator (variables+=ID variables+=ID+)? body=OclExpression)
	 */
	protected void sequence_MultiaryIteration(ISerializationContext context, MultiaryIteration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|QualifiedName] 
	 *         (stringValues+=STRING | numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual) 
	 *         stringValues+=STRING? 
	 *         (
	 *             (numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)? 
	 *             stringValues+=STRING?
	 *         )*
	 *     )
	 */
	protected void sequence_MultipleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllModelElements returns AttributeAssignment
	 *     FeatureAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             attribute=[Attribute|QualifiedName] 
	 *             (stringValues+=STRING | numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)
	 *         ) | 
	 *         (
	 *             attribute=[Attribute|QualifiedName] 
	 *             (stringValues+=STRING | numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual) 
	 *             stringValues+=STRING? 
	 *             (
	 *                 (numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)? 
	 *                 stringValues+=STRING?
	 *             )*
	 *         )
	 *     )
	 */
	protected void sequence_MultipleAttributeAssignment_SingleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleReferenceAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName] values+=[EntityDeclaration|QualifiedName]*)
	 */
	protected void sequence_MultipleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllModelElements returns ReferenceAssignment
	 *     FeatureAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (
	 *         (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName]) | 
	 *         (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName] values+=[EntityDeclaration|QualifiedName]*)
	 *     )
	 */
	protected void sequence_MultipleReferenceAssignment_SingleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleSimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|QualifiedName] 
	 *         (stringValues+=STRING | numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual) 
	 *         stringValues+=STRING? 
	 *         (
	 *             (numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)? 
	 *             stringValues+=STRING?
	 *         )*
	 *     )
	 */
	protected void sequence_MultipleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             attribute=[Attribute|QualifiedName] 
	 *             (stringValues+=STRING | numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)
	 *         ) | 
	 *         (
	 *             attribute=[Attribute|QualifiedName] 
	 *             (stringValues+=STRING | numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual) 
	 *             booleanValues+=BOOLEAN? 
	 *             (
	 *                 (stringValues+=STRING | numberValues+=NUMBER | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)? 
	 *                 booleanValues+=BOOLEAN?
	 *             )*
	 *         )
	 *     )
	 */
	protected void sequence_MultipleSimpleAttributeAssignment_SingleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicationExpression returns MultiplicationExpression
	 *
	 * Constraint:
	 *     (left=UnaryExpression right+=MultiplicationOperation*)
	 */
	protected void sequence_MultiplicationExpression(ISerializationContext context, MultiplicationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicationOperation returns MultiplicationOperation
	 *
	 * Constraint:
	 *     (operator=MultiplicationOperator right=UnaryExpression)
	 */
	protected void sequence_MultiplicationOperation(ISerializationContext context, MultiplicationOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MULTIPLICATION_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MULTIPLICATION_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MULTIPLICATION_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MULTIPLICATION_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationOperationAccess().getOperatorMultiplicationOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMultiplicationOperationAccess().getRightUnaryExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NavigationSource returns NavigationSource
	 *
	 * Constraint:
	 *     (source=TypeLiteralExpression | source=VariableExpression)
	 */
	protected void sequence_NavigationSource(ISerializationContext context, NavigationSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns NullLiteralExpression
	 *     LiteralExpression returns NullLiteralExpression
	 *     PrimitiveLiteralExpression returns NullLiteralExpression
	 *     NullLiteralExpression returns NullLiteralExpression
	 *
	 * Constraint:
	 *     nullSymbol='null'
	 */
	protected void sequence_NullLiteralExpression(ISerializationContext context, NullLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NULL_LITERAL_EXPRESSION__NULL_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NULL_LITERAL_EXPRESSION__NULL_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNullLiteralExpressionAccess().getNullSymbolNullKeyword_0(), semanticObject.getNullSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns NumberLiteralExpression
	 *     LiteralExpression returns NumberLiteralExpression
	 *     PrimitiveLiteralExpression returns NumberLiteralExpression
	 *     NumberLiteralExpression returns NumberLiteralExpression
	 *
	 * Constraint:
	 *     numberSymbol=NUMBER_LITERAL
	 */
	protected void sequence_NumberLiteralExpression(ISerializationContext context, NumberLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NUMBER_LITERAL_EXPRESSION__NUMBER_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NUMBER_LITERAL_EXPRESSION__NUMBER_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralExpressionAccess().getNumberSymbolNUMBER_LITERALParserRuleCall_0(), semanticObject.getNumberSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OrExpression returns OrExpression
	 *
	 * Constraint:
	 *     (left=AndExpression right+=AndExpression*)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelElement returns OrderlessClass
	 *     AllModelElements returns OrderlessClass
	 *     EntityDeclaration returns OrderlessClass
	 *     Class returns OrderlessClass
	 *     HigherOrderClass returns OrderlessClass
	 *     ClassIntoOrderedOrOrderless returns OrderlessClass
	 *     OrderlessClass returns OrderlessClass
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (classifiers+=[Class|QualifiedName] classifiers+=[Class|QualifiedName]*)? 
	 *         (superClasses+=[Class|QualifiedName] superClasses+=[Class|QualifiedName]*)? 
	 *         (subordinators+=[HigherOrderClass|QualifiedName] subordinators+=[HigherOrderClass|QualifiedName]*)? 
	 *         ((categorizationType=CategorizationType categorizedClass=[Class|QualifiedName]) | powertypeOf=[Class|QualifiedName])? 
	 *         (assignments+=FeatureAssignment | features+=Feature)*
	 *     )
	 */
	protected void sequence_OrderlessClass(ISerializationContext context, OrderlessClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns PrimitiveTypeLiteral
	 *     LiteralExpression returns PrimitiveTypeLiteral
	 *     TypeLiteralExpression returns PrimitiveTypeLiteral
	 *     PrimitiveTypeLiteral returns PrimitiveTypeLiteral
	 *
	 * Constraint:
	 *     (typeName='Boolean' | typeName='Number' | typeName='String')
	 */
	protected void sequence_PrimitiveTypeLiteral(ISerializationContext context, PrimitiveTypeLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllModelElements returns Reference
	 *     Feature returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         _type=[Class|QualifiedName] 
	 *         (subsetOf+=[Reference|QualifiedName] subsetOf+=[Reference|QualifiedName]*)? 
	 *         oppositeTo=[Reference|QualifiedName]?
	 *     )
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllModelElements returns RegularityAttribute
	 *     Feature returns RegularityAttribute
	 *     Attribute returns RegularityAttribute
	 *     RegularityAttribute returns RegularityAttribute
	 *     FeatureIntoRegularityFeature returns RegularityAttribute
	 *     RegularityFeature returns RegularityAttribute
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         (primitiveType=PrimitiveType | _type=[DataType|QualifiedName]) 
	 *         (subsetOf+=[Attribute|QualifiedName] subsetOf+=[Attribute|QualifiedName]*)? 
	 *         regularityType=RegularityFeatureType 
	 *         regulates=[Attribute|QualifiedName]
	 *     )
	 */
	protected void sequence_RegularityAttribute(ISerializationContext context, RegularityAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllModelElements returns RegularityReference
	 *     Feature returns RegularityReference
	 *     Reference returns RegularityReference
	 *     RegularityReference returns RegularityReference
	 *     FeatureIntoRegularityFeature returns RegularityReference
	 *     RegularityFeature returns RegularityReference
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (lowerBound=CARDINALITY upperBound=CARDINALITY)? 
	 *         _type=[Class|QualifiedName] 
	 *         (subsetOf+=[Reference|QualifiedName] subsetOf+=[Reference|QualifiedName]*)? 
	 *         oppositeTo=[Reference|QualifiedName]? 
	 *         regularityType=RegularityFeatureType 
	 *         regulates=[Reference|QualifiedName]
	 *     )
	 */
	protected void sequence_RegularityReference(ISerializationContext context, RegularityReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (left=AdditionExpression right+=RelationalOperation*)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalOperation returns RelationalOperation
	 *
	 * Constraint:
	 *     (operator=RelationalOperator right=AdditionExpression)
	 */
	protected void sequence_RelationalOperation(ISerializationContext context, RelationalOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.RELATIONAL_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.RELATIONAL_OPERATION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.RELATIONAL_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.RELATIONAL_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalOperationAccess().getOperatorRelationalOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRelationalOperationAccess().getRightAdditionExpressionParserRuleCall_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns SetLiteralExpression
	 *     LiteralExpression returns SetLiteralExpression
	 *     SetLiteralExpression returns SetLiteralExpression
	 *
	 * Constraint:
	 *     (parts+=PrimitiveLiteralExpression parts+=PrimitiveLiteralExpression*)?
	 */
	protected void sequence_SetLiteralExpression(ISerializationContext context, SetLiteralExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns SetTypeLiteral
	 *     LiteralExpression returns SetTypeLiteral
	 *     TypeLiteralExpression returns SetTypeLiteral
	 *     SetTypeLiteral returns SetTypeLiteral
	 *
	 * Constraint:
	 *     (typeName='Set' setType=TypeLiteralExpression)
	 */
	protected void sequence_SetTypeLiteral(ISerializationContext context, SetTypeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.SET_TYPE_LITERAL__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.SET_TYPE_LITERAL__TYPE_NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.SET_TYPE_LITERAL__SET_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.SET_TYPE_LITERAL__SET_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetTypeLiteralAccess().getTypeNameSetKeyword_0_0(), semanticObject.getTypeName());
		feeder.accept(grammarAccess.getSetTypeLiteralAccess().getSetTypeTypeLiteralExpressionParserRuleCall_2_0(), semanticObject.getSetType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SingleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|QualifiedName] 
	 *         (stringValues+=STRING | numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)
	 *     )
	 */
	protected void sequence_SingleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleReferenceAssignment returns ReferenceAssignment
	 *
	 * Constraint:
	 *     (reference=[Reference|QualifiedName] values+=[EntityDeclaration|QualifiedName])
	 */
	protected void sequence_SingleReferenceAssignment(ISerializationContext context, ReferenceAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleSimpleAttributeAssignment returns AttributeAssignment
	 *
	 * Constraint:
	 *     (
	 *         attribute=[Attribute|QualifiedName] 
	 *         (stringValues+=STRING | numberValues+=NUMBER | booleanValues+=BOOLEAN | datatypeValues+=[Individual|QualifiedName] | unnamedValues+=UnnamedIndividual)
	 *     )
	 */
	protected void sequence_SingleSimpleAttributeAssignment(ISerializationContext context, AttributeAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns StringLiteralExpression
	 *     LiteralExpression returns StringLiteralExpression
	 *     PrimitiveLiteralExpression returns StringLiteralExpression
	 *     StringLiteralExpression returns StringLiteralExpression
	 *
	 * Constraint:
	 *     stringSymbol=STRING
	 */
	protected void sequence_StringLiteralExpression(ISerializationContext context, StringLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.STRING_LITERAL_EXPRESSION__STRING_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.STRING_LITERAL_EXPRESSION__STRING_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpressionAccess().getStringSymbolSTRINGTerminalRuleCall_0(), semanticObject.getStringSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns TypeOperation
	 *     DotOperation returns TypeOperation
	 *     ArrowOperation returns TypeOperation
	 *     TypeOperation returns TypeOperation
	 *
	 * Constraint:
	 *     (operator=TypeOperator referredType=TypeLiteralExpression?)
	 */
	protected void sequence_TypeOperation(ISerializationContext context, TypeOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (operator=UnaryOperator? right=TermExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns UnaryIteration
	 *     ArrowOperation returns UnaryIteration
	 *     UnaryIteration returns UnaryIteration
	 *
	 * Constraint:
	 *     (iterator=UnaryIterator variable=ID? body=OclExpression)
	 */
	protected void sequence_UnaryIteration(ISerializationContext context, UnaryIteration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns UnaryNumberOperation
	 *     DotOperation returns UnaryNumberOperation
	 *     UnaryNumberOperation returns UnaryNumberOperation
	 *
	 * Constraint:
	 *     operator=UnaryNumberOperator
	 */
	protected void sequence_UnaryNumberOperation(ISerializationContext context, UnaryNumberOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.UNARY_NUMBER_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.UNARY_NUMBER_OPERATION__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryNumberOperationAccess().getOperatorUnaryNumberOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns UnarySetOperation
	 *     ArrowOperation returns UnarySetOperation
	 *     UnarySetOperation returns UnarySetOperation
	 *
	 * Constraint:
	 *     operator=UnarySetOperator
	 */
	protected void sequence_UnarySetOperation(ISerializationContext context, UnarySetOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.UNARY_SET_OPERATION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.UNARY_SET_OPERATION__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnarySetOperationAccess().getOperatorUnarySetOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnnamedIndividual returns Individual
	 *
	 * Constraint:
	 *     assignments+=SimpleAttributeAssignment*
	 */
	protected void sequence_UnnamedIndividual(ISerializationContext context, Individual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermExpression returns UserDefinedTypeLiteral
	 *     LiteralExpression returns UserDefinedTypeLiteral
	 *     TypeLiteralExpression returns UserDefinedTypeLiteral
	 *     UserDefinedTypeLiteral returns UserDefinedTypeLiteral
	 *
	 * Constraint:
	 *     typeName=[Class|ID]
	 */
	protected void sequence_UserDefinedTypeLiteral(ISerializationContext context, UserDefinedTypeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.USER_DEFINED_TYPE_LITERAL__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.USER_DEFINED_TYPE_LITERAL__TYPE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUserDefinedTypeLiteralAccess().getTypeNameClassIDTerminalRuleCall_0_1(), semanticObject.eGet(ModelPackage.Literals.USER_DEFINED_TYPE_LITERAL__TYPE_NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (variableName=ID variableType=TypeLiteralExpression initialValue=ImpliesExpression)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__VARIABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__VARIABLE_NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__VARIABLE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__VARIABLE_TYPE));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__INITIAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.VARIABLE_DECLARATION__INITIAL_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getVariableNameIDTerminalRuleCall_0_0(), semanticObject.getVariableName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getVariableTypeTypeLiteralExpressionParserRuleCall_2_0(), semanticObject.getVariableType());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getInitialValueImpliesExpressionParserRuleCall_4_0(), semanticObject.getInitialValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CallOperation returns VariableExpression
	 *     DotOperation returns VariableExpression
	 *     VariableExpression returns VariableExpression
	 *
	 * Constraint:
	 *     (referringVariable='self' | referringVariable=ID)
	 */
	protected void sequence_VariableExpression(ISerializationContext context, VariableExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XorExpression returns XorExpression
	 *
	 * Constraint:
	 *     (left=OrExpression right+=OrExpression*)
	 */
	protected void sequence_XorExpression(ISerializationContext context, XorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
