/**
 * generated by Xtext 2.21.0
 */
package br.ufes.inf.nemo.ml2.validation;

import br.ufes.inf.nemo.ml2.model.DataType;
import br.ufes.inf.nemo.ml2.model.EntityDeclaration;
import br.ufes.inf.nemo.ml2.model.Feature;
import br.ufes.inf.nemo.ml2.model.FeatureAssignment;
import br.ufes.inf.nemo.ml2.model.GeneralizationSet;
import br.ufes.inf.nemo.ml2.model.HighOrderClass;
import br.ufes.inf.nemo.ml2.model.HigherOrderClass;
import br.ufes.inf.nemo.ml2.model.ReferenceAssignment;
import br.ufes.inf.nemo.ml2.model.RegularityFeature;
import br.ufes.inf.nemo.ml2.util.ML2Util;
import br.ufes.inf.nemo.ml2.validation.AbstractML2Validator;
import br.ufes.inf.nemo.ml2.validation.LinguisticRules;
import br.ufes.inf.nemo.ml2.validation.MLTRules;
import br.ufes.inf.nemo.ml2.validation.UFORules;
import br.ufes.inf.nemo.ml2.validation.ValidationError;
import br.ufes.inf.nemo.ml2.validation.ValidationIssue;
import br.ufes.inf.nemo.ml2.validation.ValidationWarning;
import com.google.inject.Inject;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ML2Validator extends AbstractML2Validator {
  @Inject
  @Extension
  private ML2Util _mL2Util;
  
  @Inject
  @Extension
  private LinguisticRules _linguisticRules;
  
  @Inject
  @Extension
  private MLTRules _mLTRules;
  
  @Inject
  @Extension
  private UFORules _uFORules;
  
  public static final String INSTANTIATION_OF_DISJOINT_TYPES = "br.ufes.inf.nemo.ontol.InstantiationOfDisjointTypes";
  
  public static final String MISSING_COMPLETE_INSTANTIATION = "br.ufes.inf.nemo.ontol.MissingCompleteInstantiation";
  
  public static final String POWERTYPE_COMPLETE_SPECIALIZATION = "br.ufes.inf.nemo.ontol.PowertypeCompleteSpecialization";
  
  public static final String COMPLETE_CHARACTERIZATION_AND_COMPLETENESS = "br.ufes.inf.nemo.ontol.CompleteCharacterizationAndCompleteness";
  
  public static final String DISJOINT_CHARACTERIZATION_AND_DISJOINTNESS = "br.ufes.inf.nemo.ontol.DisjointCharacterizationAndDisjointness";
  
  public static final String MANDATORY_SPECIALIZATION_OF_ENDURANT = "br.ufes.inf.nemo.ontol.MandaorySpecializationOfEndurant";
  
  public static final String NONSORTAL_SPECIALIZING_SORTAL = "br.ufes.inf.nemo.ontol.NonSortalSpecializingSortal";
  
  public static final String RIGID_SPECIALIZING_ANTIRIGID = "br.ufes.inf.nemo.ontol.RigidSpecializingAntiRigid";
  
  public static final String SEMIRIGID_SPECIALIZING_ANTIRIGID = "br.ufes.inf.nemo.ontol.SemiRigidSpecializingAntiRigid";
  
  public static final String MULTIPLE_IDENTITIES = "br.ufes.inf.nemo.ontol.MultipleIdentities";
  
  public static final String MISSING_IDENTITY = "br.ufes.inf.nemo.ontol.MissingIdentity";
  
  public static final String NECESSARY_INSTANTIATION = "br.ufes.inf.nemo.ontol.NecessaryInstantiation";
  
  public static final String MISSING_SPECIALIZATION_TO_BASETYPE = "br.ufes.inf.nemo.ontol.MissingSpecializationToBasetype";
  
  public static final String UFO_A_MISSING_MUST_INSTANTIATION = "br.ufes.inf.nemo.ontol.ufo.a.MissingMustInstantiation";
  
  public static final String UFO_A_ILLEGAL_SORTAL_SPECIALIZATION = "br.ufes.inf.nemo.ontol.ufo.a.IllegalSortalSpecialization";
  
  public static final String UFO_A_ILLEGAL_RIGID_SPECIALIZATION = "br.ufes.inf.nemo.ontol.ufo.a.IllegalRigidSpecialization";
  
  public static final String NON_CONFORMANT_ASSIGNMENT = "br.ufes.inf.nemo.ontol.NonConformantAssigment";
  
  @Check(CheckType.FAST)
  public void callIsNameValid(final EntityDeclaration e) {
    ValidationError _isNameValid = this._linguisticRules.isNameValid(e);
    if (_isNameValid!=null) {
      this.runIssue(_isNameValid);
    }
  }
  
  @Check(CheckType.FAST)
  public void callDuplicatedEntityName(final EntityDeclaration e) {
    ValidationError _duplicatedEntityName = this._linguisticRules.duplicatedEntityName(e);
    if (_duplicatedEntityName!=null) {
      this.runIssue(_duplicatedEntityName);
    }
  }
  
  @Check(CheckType.FAST)
  public void calIsValidInstantiation(final EntityDeclaration e) {
    ValidationIssue _isValidInstantiation = this._linguisticRules.isValidInstantiation(e);
    if (_isValidInstantiation!=null) {
      this.runIssue(_isValidInstantiation);
    }
  }
  
  @Check(CheckType.FAST)
  public void callIsValidSpecialization(final br.ufes.inf.nemo.ml2.model.Class c) {
    ValidationError _isValidSpecialization = this._linguisticRules.isValidSpecialization(c);
    if (_isValidSpecialization!=null) {
      this.runIssue(_isValidSpecialization);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void callHasCyclicSpecialization(final br.ufes.inf.nemo.ml2.model.Class c) {
    final Set<br.ufes.inf.nemo.ml2.model.Class> ch = this._mL2Util.classHierarchy(c);
    ValidationError _hasCyclicSpecialization = this._linguisticRules.hasCyclicSpecialization(c, ch);
    if (_hasCyclicSpecialization!=null) {
      this.runIssue(_hasCyclicSpecialization);
    }
  }
  
  @Check(CheckType.FAST)
  public void callHasValidCategorizedClass(final HigherOrderClass c) {
    ValidationError _hasValidCategorizedClass = this._linguisticRules.hasValidCategorizedClass(c);
    if (_hasValidCategorizedClass!=null) {
      this.runIssue(_hasValidCategorizedClass);
    }
  }
  
  @Check(CheckType.FAST)
  public void callHasValidPowertypeRelation(final HigherOrderClass c) {
    ValidationError _hasValidPowertypeRelation = this._linguisticRules.hasValidPowertypeRelation(c);
    if (_hasValidPowertypeRelation!=null) {
      this.runIssue(_hasValidPowertypeRelation);
    }
  }
  
  @Check(CheckType.FAST)
  public void callHasValidSubordinators(final HigherOrderClass c) {
    ValidationError _hasValidSubordinators = this._linguisticRules.hasValidSubordinators(c);
    if (_hasValidSubordinators!=null) {
      this.runIssue(_hasValidSubordinators);
    }
  }
  
  @Check(CheckType.FAST)
  public void fastChecksOnDataTypes(final DataType d) {
    ValidationIssue _containsReferences = this._linguisticRules.containsReferences(d);
    if (_containsReferences!=null) {
      this.runIssue(_containsReferences);
    }
  }
  
  @Check(CheckType.FAST)
  public void fastChecksOnHOClass(final HighOrderClass ho) {
    ValidationError _minOrder = this._mLTRules.minOrder(ho);
    if (_minOrder!=null) {
      this.runIssue(_minOrder);
    }
  }
  
  @Check(CheckType.FAST)
  public void fastChecksOnGeneralizationSet(final GeneralizationSet gs) {
    ValidationError _hasValidMembers = this._linguisticRules.hasValidMembers(gs);
    if (_hasValidMembers!=null) {
      this.runIssue(_hasValidMembers);
    }
  }
  
  @Check(CheckType.FAST)
  public void callCheckFeatureName(final Feature f) {
    ValidationError _checkFeatureName = this._linguisticRules.checkFeatureName(f);
    if (_checkFeatureName!=null) {
      this.runIssue(_checkFeatureName);
    }
  }
  
  @Check(CheckType.FAST)
  public void callCheckSubsettedMultiplicity(final Feature f) {
    ValidationIssue _checkSubsettedMultiplicity = this._linguisticRules.checkSubsettedMultiplicity(f);
    if (_checkSubsettedMultiplicity!=null) {
      this.runIssue(_checkSubsettedMultiplicity);
    }
  }
  
  @Check(CheckType.FAST)
  public void callCheckRegularityAndContainer(final RegularityFeature f) {
    ValidationIssue _checkRegularityAndContainer = this._linguisticRules.checkRegularityAndContainer(f);
    if (_checkRegularityAndContainer!=null) {
      this.runIssue(_checkRegularityAndContainer);
    }
  }
  
  @Check(CheckType.FAST)
  public void fastChecksOnFeatureAssignment(final FeatureAssignment fa) {
    ValidationIssue _checkMultiplicityAndAssignment = this._linguisticRules.checkMultiplicityAndAssignment(fa);
    if (_checkMultiplicityAndAssignment!=null) {
      this.runIssue(_checkMultiplicityAndAssignment);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void callCheckFeatureAssignmentType(final FeatureAssignment fa) {
    ValidationIssue _checkFeatureAssignmentType = this._linguisticRules.checkFeatureAssignmentType(fa);
    if (_checkFeatureAssignmentType!=null) {
      this.runIssue(_checkFeatureAssignmentType);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void callCheckRegularityFeatureConformance(final ReferenceAssignment fa) {
    ValidationIssue _checkRegularityFeatureConformance = this._linguisticRules.checkRegularityFeatureConformance(fa);
    if (_checkRegularityFeatureConformance!=null) {
      this.runIssue(_checkRegularityFeatureConformance);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void callMissingInstantiationByCompleteness(final EntityDeclaration e) {
    final LinkedHashSet<br.ufes.inf.nemo.ml2.model.Class> iof = this._mL2Util.getAllInstantiatedClasses(e);
    ValidationIssue _missingInstantiationByCompleteness = this._linguisticRules.missingInstantiationByCompleteness(e, iof);
    if (_missingInstantiationByCompleteness!=null) {
      this.runIssue(_missingInstantiationByCompleteness);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void callIsInstanceOfDisjointClasses(final EntityDeclaration e) {
    final LinkedHashSet<br.ufes.inf.nemo.ml2.model.Class> iof = this._mL2Util.getAllInstantiatedClasses(e);
    ValidationIssue _isInstanceOfDisjointClasses = this._linguisticRules.isInstanceOfDisjointClasses(e, iof);
    if (_isInstanceOfDisjointClasses!=null) {
      this.runIssue(_isInstanceOfDisjointClasses);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void callIsMissingSpecializationThroughPowertype(final br.ufes.inf.nemo.ml2.model.Class c) {
    final Set<br.ufes.inf.nemo.ml2.model.Class> ch = this._mL2Util.classHierarchy(c);
    final LinkedHashSet<br.ufes.inf.nemo.ml2.model.Class> iof = this._mL2Util.getAllInstantiatedClasses(c);
    ValidationError _isMissingSpecializationThroughPowertype = this._mLTRules.isMissingSpecializationThroughPowertype(c, ch, iof);
    if (_isMissingSpecializationThroughPowertype!=null) {
      this.runIssue(_isMissingSpecializationThroughPowertype);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void callHasSimpleSubordinationCycle(final HigherOrderClass c) {
    ValidationError _hasSimpleSubordinationCycle = this._linguisticRules.hasSimpleSubordinationCycle(c);
    if (_hasSimpleSubordinationCycle!=null) {
      this.runIssue(_hasSimpleSubordinationCycle);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void callIsSpecializingDisjointClasses(final br.ufes.inf.nemo.ml2.model.Class c) {
    final Set<br.ufes.inf.nemo.ml2.model.Class> ch = this._mL2Util.classHierarchy(c);
    ValidationIssue _isSpecializingDisjointClasses = this._linguisticRules.isSpecializingDisjointClasses(c, ch);
    if (_isSpecializingDisjointClasses!=null) {
      this.runIssue(_isSpecializingDisjointClasses);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void callCheckInstantiatedRegularities(final br.ufes.inf.nemo.ml2.model.Class c) {
    ValidationIssue _checkInstantiatedRegularities = this._linguisticRules.checkInstantiatedRegularities(c);
    if (_checkInstantiatedRegularities!=null) {
      this.runIssue(_checkInstantiatedRegularities);
    }
  }
  
  private void _runIssue(final ValidationError issue) {
    final ValidationError it = issue;
    if (((((it.getSource() != null) && (it.getFeature() != null)) && (it.getIndex() != (-1))) && (it.getCode() != null))) {
      this.error(it.getMessage(), it.getSource(), it.getFeature(), it.getIndex(), it.getCode(), it.getIssueData());
    } else {
      if ((((it.getSource() != null) && (it.getFeature() != null)) && (it.getCode() != null))) {
        this.error(it.getMessage(), it.getSource(), it.getFeature(), it.getCode(), it.getIssueData());
      } else {
        if ((((it.getFeature() != null) && (it.getIndex() != (-1))) && (it.getCode() != null))) {
          this.error(it.getMessage(), it.getFeature(), it.getIndex(), it.getCode(), it.getIssueData());
        } else {
          if ((((it.getSource() != null) && (it.getFeature() != null)) && (it.getIndex() != (-1)))) {
            this.error(it.getMessage(), it.getSource(), it.getFeature(), it.getIndex());
          } else {
            if (((it.getSource() != null) && (it.getFeature() != null))) {
              this.error(it.getMessage(), it.getSource(), it.getFeature());
            } else {
              if (((it.getFeature() != null) && (it.getCode() != null))) {
                this.error(it.getMessage(), it.getFeature(), it.getCode(), it.getIssueData());
              } else {
                if (((it.getFeature() != null) && (it.getIndex() != (-1)))) {
                  this.error(it.getMessage(), it.getFeature(), it.getIndex());
                } else {
                  if (((it.getSource() != null) && (it.getFeature() != null))) {
                    this.error(it.getMessage(), it.getFeature());
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  private void _runIssue(final ValidationWarning issue) {
    final ValidationWarning it = issue;
    if (((((it.getSource() != null) && (it.getFeature() != null)) && (it.getIndex() != (-1))) && (it.getCode() != null))) {
      this.warning(it.getMessage(), it.getSource(), it.getFeature(), it.getIndex(), it.getCode(), it.getIssueData());
    } else {
      if ((((it.getSource() != null) && (it.getFeature() != null)) && (it.getCode() != null))) {
        this.warning(it.getMessage(), it.getSource(), it.getFeature(), it.getCode(), it.getIssueData());
      } else {
        if ((((it.getSource() != null) && (it.getFeature() != null)) && (it.getIndex() != (-1)))) {
          this.warning(it.getMessage(), it.getSource(), it.getFeature(), it.getIndex());
        } else {
          if (((it.getSource() != null) && (it.getFeature() != null))) {
            this.warning(it.getMessage(), it.getSource(), it.getFeature());
          } else {
            if ((((it.getFeature() != null) && (it.getIndex() != (-1))) && (it.getCode() != null))) {
              this.warning(it.getMessage(), it.getFeature(), it.getIndex(), it.getCode(), it.getIssueData());
            } else {
              if (((it.getFeature() != null) && (it.getCode() != null))) {
                this.warning(it.getMessage(), it.getFeature(), it.getCode(), it.getIssueData());
              } else {
                if (((it.getFeature() != null) && (it.getIndex() != (-1)))) {
                  this.warning(it.getMessage(), it.getFeature(), it.getIndex());
                } else {
                  if (((it.getSource() != null) && (it.getFeature() != null))) {
                    this.warning(it.getMessage(), it.getFeature());
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  private void runIssue(final ValidationIssue issue) {
    if (issue instanceof ValidationError) {
      _runIssue((ValidationError)issue);
      return;
    } else if (issue instanceof ValidationWarning) {
      _runIssue((ValidationWarning)issue);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(issue).toString());
    }
  }
}
